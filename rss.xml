<?xml version="1.0" encoding="UTF-8"?><rss xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:content="http://purl.org/rss/1.0/modules/content/" xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title><![CDATA[Gatsby Starter Blog RSS Feed]]></title><description><![CDATA[장희영의 블로그]]></description><link>https://klloo.github.io</link><generator>GatsbyJS</generator><lastBuildDate>Wed, 06 Sep 2023 12:43:41 GMT</lastBuildDate><item><title><![CDATA[No title]]></title><link>https://klloo.github.io/svg/</link><guid isPermaLink="false">https://klloo.github.io/svg/</guid><content:encoded></content:encoded></item><item><title><![CDATA[컨벡스 헐(Convex Hull) 알고리즘]]></title><description><![CDATA[…]]></description><link>https://klloo.github.io/convex-hull/</link><guid isPermaLink="false">https://klloo.github.io/convex-hull/</guid><pubDate>Wed, 06 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;친구에게 알고리즘 문제를 추천받았는데 알고리즘 분류에 &apos;볼록 껍질 알고리즘(=컨벡스헐)&apos; 이라는 분류가 있었습니다.
생전 처음 들어본 기묘한 이름에... 이게 대체 무슨 알고리즘인지 궁금해서 슬쩍 찾아봤는데 무슨 기하..외적...이런 키워드에 지레 겁먹고 미루고 미루다가 아무래도 궁금해서 드디어 공부를 해봤습니다.&lt;/p&gt;
&lt;h3&gt;개념&lt;/h3&gt;
&lt;p&gt;컨벡스 헐이란 &lt;strong&gt;차원 평면에 여러개의 점이 있을 때, 그 점 중 일부를 이어서 나머지 점을 내부에 포함할 수 있는 볼록 다각형을 만드는 알고리즘&lt;/strong&gt;입니다.&lt;/p&gt;
&lt;p&gt;여기서 &lt;strong&gt;볼록 다각형&lt;/strong&gt;이란 경계의 두 점을 잇는 어떤 선분도 다각형 외부로 나가지 않는 단순 다각형을 의미합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 286px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/5c74159bc8a2a7260b2c14e4b055d47d/357e3/example.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 50.724637681159415%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABFUlEQVR42qVSa3fCIAz1///LedzOCqiUN7Q0y81mrev0y/KNkNwXHIhrWRbaVs6ZWmv0quZ5pnEcd/3D9tB7Z7BE2igqJT8Fm6bGYFcyPPcnYEqJYgwUgqdaiwDH6GXxDjKRc44JI88HUQjyLTGcCiDArDW39nqJfmt1tWjMwOciZ2staW2EFHMPCtFMya22oQTAAIWK6/VCJRdR1/ssfe9HMmctOyD13kmmAliZNQT7AziTUgMv9XXY2otYDmFkNY7Jo1g9Ht8kIlHMmYYQvgGBroYPsfW7kCX6UKXU5+6xYBeZwsnDK98zaxIBBsCuNUDK0xfH3pmtQ9Tu28DW6f0klgBWaxZFyPVV4f5mffcP8YX+U18rSxIfOcw67AAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;example&quot;
        title=&quot;&quot;
        src=&quot;/static/5c74159bc8a2a7260b2c14e4b055d47d/357e3/example.png&quot;
        srcset=&quot;/static/5c74159bc8a2a7260b2c14e4b055d47d/948cf/example.png 138w,
/static/5c74159bc8a2a7260b2c14e4b055d47d/6b2ea/example.png 275w,
/static/5c74159bc8a2a7260b2c14e4b055d47d/357e3/example.png 286w&quot;
        sizes=&quot;(max-width: 286px) 100vw, 286px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;위 그림에서 (a)는 볼록다각형이고 (b)는 오목다각형입니다.&lt;br/&gt;
그림만봐도 외부에서 봤을 때 (a)는 모든 각이 다 볼록하고 (b)는 오목한 각이 있는 것을 볼 수 있습니다.
그리고 조금만 생각해본다면 다각형의 모든 내각이 180도 이하일 때 볼록 다각형이 된다는 것을 알 수 있습니다.&lt;/p&gt;
&lt;p&gt;아무튼 아래와 같이 점들이 2차원 좌표 평면에 존재할 때, 컨벡스 헐을 나타내보면 다음과 같습니다.
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/068a82d142db4b962296497adc3641ce/b2cef/concept.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 43.47826086956522%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAAAsTAAALEwEAmpwYAAABQklEQVR42mVS23KEIAz1//+uD/0A7c54W3QFlDunCa6WtpnJADnh5NrEGHFpSqlobQsh/HqffhE5s5L/H6y5SHLO8N5jnueb+CK/78UvIWTgIRTaaQVdkVNFSG8opeCcKwYp5U3CQersPWXbji9MOkEaD6EsHjJCOcr2HbzhT8uyFEIhBJx1BOZCtq5ryZrvXNqoAjYTcOwaL8JYfMxoF4dBbKCoJyH36diPu19a69N2HDDGwtK52YTVUlusKXYu/yBMyw2SsKf2XDsaBq216Pu+ROQA0zQVG8tO+DwO+GhFIeznBfOyFcwxuVYQJkPZWHrZ8Md6AJwZC7fBGHOWS5ij0vnTalgTRh0x7RHLEfDZPf9P+Wo8nyxd15XSr8Gk94Q5C14bH2napNoGfA3zz1DqFanJr8zqtbl3tHqXXax8vwF3e8CIRUMnLQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;concept&quot;
        title=&quot;&quot;
        src=&quot;/static/068a82d142db4b962296497adc3641ce/dd45a/concept.png&quot;
        srcset=&quot;/static/068a82d142db4b962296497adc3641ce/948cf/concept.png 138w,
/static/068a82d142db4b962296497adc3641ce/6b2ea/concept.png 275w,
/static/068a82d142db4b962296497adc3641ce/dd45a/concept.png 550w,
/static/068a82d142db4b962296497adc3641ce/d4c13/concept.png 825w,
/static/068a82d142db4b962296497adc3641ce/b2cef/concept.png 847w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;동작 원리&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;먼저 &lt;strong&gt;기준점&lt;/strong&gt;을 잡습니다.
여기서 기준점은 y좌표가 가장 작은 것으로 잡고, y좌표가 같다면 x좌표가 가장 작은 것으로 잡습니다.&lt;/li&gt;
&lt;li&gt;다음으로 기준점을 기준으로 다른 점들을 &lt;strong&gt;반시계 방향으로 정렬&lt;/strong&gt;합니다.&lt;/li&gt;
&lt;li&gt;스택에 첫번째와 두번째 점을 push하고, 3~n번째 점에 대해 아래 과정을 반복합니다.&lt;/li&gt;
&lt;li&gt;스택의 최상단에 있는 두 점을 이은 직선에 대해 현재 탐색중인 점이 왼쪽에 있다면(&lt;strong&gt;반시계 방향&lt;/strong&gt;에 있다면) 스택에 push하고 다음 점을 확인합니다.&lt;/li&gt;
&lt;li&gt;그렇지 않다면 스택을 pop하고, 위의 조건을 만족할 때 까지 확인합니다.&lt;/li&gt;
&lt;li&gt;n번째 점까지 탐색이 끝나면 스택에는 컨벡스헐을 구성하는 점들이 포함되어 있게 됩니다.&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;위의 예시로 동작 과정을 살펴보자면 아래와 같습니다.&lt;/p&gt;
&lt;p&gt;먼저 반시계 방향으로 정렬을 하면 파란색으로 적혀진 숫자대로 정렬이 되는데 여기서 1번과 2번 점을 스택에 넣고 시작합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/6bf738eeb0d59c60ecbf1fccef7ad913/ad12c/1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 53.623188405797094%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABR0lEQVR42o1Sy3KDMAzk/38onJPJjcmlhx46pRMyPFrAYF5pgs1WMjEBkk7rGWEkpGWllaO1xtqUUtBsc/9J3sLUeDucrHo1FfGRssIxzjAMwxQ3eSvr+/4h5thkDBqiuaK+AlUl8RELA85FeZ6vfijh+z6SJDG+BRsZ0qO/AfphilR2OOUtNLFjhm3bIs1GtgzOJyP/cDggDMNHwPkcCBVd16FuGgLAyKYs8RZLKPJ5rhbQ8zzEcTwBWgynvmgESW4+FEWBl+P4nmQlgk+BWpY4X2hWZvB3wO12iyiKHhnKb2o1ykzLHLiQQFSJiuJfNFAp8oXaFtB1XQRB8HvLU/B28ymJ8ev7ssiKst/vkabpJNyk8hx9vXOc2Jz7Ma7vKnO7m80Gu93OzHy+Xs6fCztbWmtCCKMwM+Sfzon8D/CJDbe1Wnf2A2oQWN5i09vWAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;stage&quot;
        title=&quot;&quot;
        src=&quot;/static/6bf738eeb0d59c60ecbf1fccef7ad913/dd45a/1.png&quot;
        srcset=&quot;/static/6bf738eeb0d59c60ecbf1fccef7ad913/948cf/1.png 138w,
/static/6bf738eeb0d59c60ecbf1fccef7ad913/6b2ea/1.png 275w,
/static/6bf738eeb0d59c60ecbf1fccef7ad913/dd45a/1.png 550w,
/static/6bf738eeb0d59c60ecbf1fccef7ad913/d4c13/1.png 825w,
/static/6bf738eeb0d59c60ecbf1fccef7ad913/ad12c/1.png 856w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;스택 최상단의 두 점(1번과 2번)을 잇고 3번 점을 확인합니다.&lt;br/&gt;
3번 점은 직선의 반시계 방향(왼쪽)에 있으므로 스택에 넣습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0de7e43a660bc317a5d2d1a9483ca872/47ff6/2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 55.79710144927537%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABeUlEQVR42oVT226CQBDl/z/JFxMfTEzU2saksS2xUAoroFBpuS27pztj2eIlcZMJyc7sucwMjlIKXdeBvhRSSrRtC6013/fR52/FMO8MLwCNpmkQ+B4CkSL57swdkfw96M5BiJjq67pmAQzYK4BWSLIC7/uagd+8ENuPCLJt+KEQ0Zliis1mA8/z4Ps+6JA7p7dJJxQx4mONJC8gConOgCVpiiiKsItTrlEDe+v1Gq7rGjLBOSJhhVqr/14Z6fvDga0orbhQRCEeXIGykcbIqZYszmYzLBYLZFl2AjStcUqpESQZM9fVDx5ffewrzmMb7OB/CmSGoDUuukH/6BDgcrn8BySFRQs8uSFkU5tijapuzWPFPfVyachyHPPMTl1dKLwCvLLM0+xsX+N4h+cX1zbdDtGc+XyO6XSKqqrsyjmXe2SDV8QorkrsvkrurVL9ehFRjMlkgtVqZadsFd6LnnSojtZlNBphPB7z+pytzb245YB6OIz+T/kFWCVT+f7/BpYAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;2&quot;
        title=&quot;&quot;
        src=&quot;/static/0de7e43a660bc317a5d2d1a9483ca872/dd45a/2.png&quot;
        srcset=&quot;/static/0de7e43a660bc317a5d2d1a9483ca872/948cf/2.png 138w,
/static/0de7e43a660bc317a5d2d1a9483ca872/6b2ea/2.png 275w,
/static/0de7e43a660bc317a5d2d1a9483ca872/dd45a/2.png 550w,
/static/0de7e43a660bc317a5d2d1a9483ca872/d4c13/2.png 825w,
/static/0de7e43a660bc317a5d2d1a9483ca872/47ff6/2.png 852w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;스택 최상단의 두 점(3번과 2번)을 잇고 4번 점을 확인합니다.&lt;br/&gt;
4번 점은 직선의 반시계 방향(왼쪽)에 있으므로 스택에 넣습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/34133838cde454570b4ab9862002973e/bad1b/3.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 54.347826086956516%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABcklEQVR42n2T226DMAyG+/6v0/uqV5Mq9WJaV6AUFbSKjZaycD4l5F8cBqMIzZKJcfBnBzurruugVfSrUKuUEqNf+8TT+9w3tVdTIG2QMPaNIC4gJBZhA2TQqX8EqgeyWiBrgZQ98PJqoqxbnSBOEhRFoe0hqe/7iKIIruuOfg0UA51zWB83fEYZzOsD9zDCLQiQpinCMERdlZAUyHvg6XSCbdswTfMZOD9CpQIjFoPFibIrZGmCd9OGn6hqZYe25RpgWRYMwxiBXBVE8auiEeDKoOx5lsLwWW/nGZyLC962CO4hsqbTQP575AFI+lShdavgeFf1sURVlgjjnEwUVYO3yxdixlDXtd6nAKqEhECO4+B4PC4feamLTdPgfD4jL0oVIkc/CcF2u53+j8tNmczhECjV6t9CsKL/f2KS8HA4YL/fw/M8XfU4NtN5WtL5zNHQU7PW6zU2mw22260eKfLrpvx35PktkN3fDSIAyfxW/QC9/VRESF8fLAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;3&quot;
        title=&quot;&quot;
        src=&quot;/static/34133838cde454570b4ab9862002973e/dd45a/3.png&quot;
        srcset=&quot;/static/34133838cde454570b4ab9862002973e/948cf/3.png 138w,
/static/34133838cde454570b4ab9862002973e/6b2ea/3.png 275w,
/static/34133838cde454570b4ab9862002973e/dd45a/3.png 550w,
/static/34133838cde454570b4ab9862002973e/d4c13/3.png 825w,
/static/34133838cde454570b4ab9862002973e/bad1b/3.png 841w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;스택 최상단의 두 점(4번과 3번)을 잇고 5번 점을 확인합니다.&lt;br/&gt;
5번 점은 직선의 시계 방향(오른쪽)에 있으므로 스택을 pop합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f8a3e3f7f046d153b41e417d13bd2b84/f96df/4.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 53.623188405797094%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABTklEQVR42n1Ta2/CMAzs//9ZCISADzANibFuCCiiW0JfIKVtHr3FkVrCgoh0SmIn53PsRMYYGG1hZ621m7uuc7Nv8/HM1iMi553IQMkWp3OKojYA7ZUeSHwopSClDOwRqevsBWkPnCs6YPB9SBCfmCOUUoFzHiiM4xjb7fYhG6eQIlkr8qLAjl1xTBmOuYBsBBjjyLLMEdLw1S2XS6zX60B95EelUZYlhKjdmuzJ8YD3A4fuaH9/4/F4jMViMQQaFP6WAk1Tu/Q+9yckhXSHkh8OnleobICbaKG9tIhwNBphNpuFhG/7C65V5Rx100K0pNTgfNVgVW19RXCJMJlMMJ/PQ8Jnpe/Tz/MMH1+7h0u9bzqdYrVahYR+27i1R9y2DbJbA/Uv0GazGRSmafpAGvmN+qph+8A0qLpUZXpDxlhI+ApahzYqCqHvBP93/QGb4FXpMJKl2AAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;4&quot;
        title=&quot;&quot;
        src=&quot;/static/f8a3e3f7f046d153b41e417d13bd2b84/dd45a/4.png&quot;
        srcset=&quot;/static/f8a3e3f7f046d153b41e417d13bd2b84/948cf/4.png 138w,
/static/f8a3e3f7f046d153b41e417d13bd2b84/6b2ea/4.png 275w,
/static/f8a3e3f7f046d153b41e417d13bd2b84/dd45a/4.png 550w,
/static/f8a3e3f7f046d153b41e417d13bd2b84/d4c13/4.png 825w,
/static/f8a3e3f7f046d153b41e417d13bd2b84/f96df/4.png 849w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;스택 최상단의 두 점(3번과 2번)을 잇고 5번 점을 다시 확인합니다.&lt;br/&gt;
5번 점은 직선의 반시계 방향(왼쪽)에 있으므로 스택에 넣습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/46b0c511453163b90ffb25c823b07cd2/27b8e/5.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 51.449275362318836%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABXklEQVR42m1S0W7CMAzk/z+GRx55RYgKTVDEpDGgiEJBK4y2Sdo06S22CGuBSFbd2Hc+x+5Za2GMAX29aV3z3fP9s7Xj3u95R2uNvCjQAEiOBwTLLaz7aVxMlSXqulukcLlZlkEIgaZpuoSGqtQVwu8Yx6LB5XLFdhcjTVNOPJ9PUEoykIjpzGYzhGHIOXTongm9XEr+vd244tdmB+PUlU7ZKUmw2kQoDRzAOKBhgul0islkwvl0Hgr9GxBhVZWIkhRCSgYrUUA6wHqf4Kos9f9QGAQBRqMRF+20fBIWy/Xe5RrkeY7P/YUBotT42PygyDPXrnqoIGsrlFJ2CZW2yIRiRaz0/gT0rkIbHOIYlRuYdSCKe4Xj8RjD4dB1VXUJn9egsyq1xmIVQVaG2/UxIqWBLBYLJnxZG//j/bbVbf+uLooi9Pt9DAYDzOfz91N+u7zmdYH/l1/zQNpiiPAPizoGuVgkTPoAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;5&quot;
        title=&quot;&quot;
        src=&quot;/static/46b0c511453163b90ffb25c823b07cd2/dd45a/5.png&quot;
        srcset=&quot;/static/46b0c511453163b90ffb25c823b07cd2/948cf/5.png 138w,
/static/46b0c511453163b90ffb25c823b07cd2/6b2ea/5.png 275w,
/static/46b0c511453163b90ffb25c823b07cd2/dd45a/5.png 550w,
/static/46b0c511453163b90ffb25c823b07cd2/d4c13/5.png 825w,
/static/46b0c511453163b90ffb25c823b07cd2/27b8e/5.png 836w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;스택 최상단의 두 점(5번과 3번)을 잇고 6번 점을 확인합니다.&lt;br/&gt;
6번 점은 직선의 시계 방향(오른쪽)에 있으므로 스택을 pop합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/603ca3818e071424d50c532a6b0fa4ed/b2cef/6.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 50.724637681159415%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABWUlEQVR42n1S226CQBT0///IF598MOoDmLSWGNJUyqq1FkRZlr0w3bOwBFuV5ITd4TAz5zIyxkBTaO2C7kq1b39/Fn9zRkMiIm4aYL9jWCffMIDDRV1Dq6GgAucceZ67sxkYcoSNZSkvBdbbLxxLg4ILbNM9sixzyYfDHlJKd6bcqqoQvUUIgxC1FSPMi428VUo6ZTmEqBCz1h0vS7A0xXvCIA25bcWFEAjDEMvl0gndJSRQWrXjuURty1CytneBS1Eg/jzgUttedITkKggCzOfz3nlPyAqNzQdDY4HifMZml4GekyV+SX5cK7wLL0wOV6vVfYdcalxtz0wHNF0obXAVCjuWQlrHfhPoZxrEYrHAdDq9GcpNyUa34T+40gTHa5w48mFrqN9UchRF/x36cT8KpYZn5doxm80wHo8xmUwQx7HDiNitTW9XP1jaO8tNOBHQcPod7hz+AsquB8YVhe77AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;6&quot;
        title=&quot;&quot;
        src=&quot;/static/603ca3818e071424d50c532a6b0fa4ed/dd45a/6.png&quot;
        srcset=&quot;/static/603ca3818e071424d50c532a6b0fa4ed/948cf/6.png 138w,
/static/603ca3818e071424d50c532a6b0fa4ed/6b2ea/6.png 275w,
/static/603ca3818e071424d50c532a6b0fa4ed/dd45a/6.png 550w,
/static/603ca3818e071424d50c532a6b0fa4ed/d4c13/6.png 825w,
/static/603ca3818e071424d50c532a6b0fa4ed/b2cef/6.png 847w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;스택 최상단의 두 점(3번과 2번)을 잇고 6번 점을 다시 확인합니다.&lt;br/&gt;
6번 점은 직선의 반시계 방향(왼쪽)에 있으므로 스택에 넣습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/967c57ca4bf3861f729e10927d6320da/d26aa/7.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 52.17391304347826%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABTUlEQVR42oVS226CQBD1/z/KB+MDRpO+NKS2tUBUWrAqCiywF053hi4FbdNJTvY2l3NmZ2KMgYPWGm1rUNc1GtWdu7sWQ79bkI9bJ7yxsFGQpkXdSDyvn/CwDvmO3suyHAQZLhDHMcLQ+lhzRTmhYyHKAo+bPfaHM94zgdPphOPxyGyT5KNnq42GlBKr1QqLxYITKaW4GK0Tt0nT1Do2yPMc8eeFK1OyeLeFH8SWPWC+WZL/crlkOIa9ZKk6GWR5USA65PxYCQEhSlyyDNs0g9Qk/yeQ2BHuEq6TEptoxw/nc4aX3QGtVlZ2hdfkiuJ66QMcnGRi6Ho3YKj7Hgyh7AeJqkYQBCMWBLL5fA7P8+4Zjr+/A59t5aau8La3vdVguRRARp9FDH3fR2Hb5MbqLuF/ICVkxGw2m2E6nSKKop7laGz+AiW5Pf9WyI3NF17uBnCw8EaNAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;7&quot;
        title=&quot;&quot;
        src=&quot;/static/967c57ca4bf3861f729e10927d6320da/dd45a/7.png&quot;
        srcset=&quot;/static/967c57ca4bf3861f729e10927d6320da/948cf/7.png 138w,
/static/967c57ca4bf3861f729e10927d6320da/6b2ea/7.png 275w,
/static/967c57ca4bf3861f729e10927d6320da/dd45a/7.png 550w,
/static/967c57ca4bf3861f729e10927d6320da/d4c13/7.png 825w,
/static/967c57ca4bf3861f729e10927d6320da/d26aa/7.png 839w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;스택 최상단의 두 점(6번과 3번)을 잇고 7번 점을 확인합니다.&lt;br/&gt;
7번 점은 직선의 반시계 방향(왼쪽)에 있으므로 스택에 넣습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/347e260d2526e22416d735da1d6ed7dd/8bd7c/8.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 49.275362318840585%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABXklEQVR42o1TC27CMAzt/W/DCTgBIAZCaMDKRmkLtFXShH5I2rfaIyhjQlokS/HzJ++5btB1HZxZa9no3vc9/Ngrc/md/fEDP+iahGGIXXQekp+KPKvrGkIIWPM7FrhGt7bBOsqQFQKH+ITNPoJWimNpmsIYwwV0rtcrVqsVZrMZVKkY8xj2nBxFEXb7L2itsb8oDDCklEiTBHF6Yp+Y0gPUcLlcYj6foyxLbuhUBMbc0DQNA1mWQ+oaVV3xI3aIFXmGt12MygB9Z7m4qiosFgtMJhModWfoJK8TicMxZvDzcMT6KPh+EQofSTHIlmja9jFfJ5kYkmTH8NEwEQ3yomBQSjGwvAy3Hrq1OKkb8uz8mJ8vmRhOp1Meyy/Jr1aBjtYKy/cQncfAfURqSCz/rA0BPK/7DvpGuK5bGCq6+3RI6mg0wng8xnazZcypCP6zvM/Maf9oleI45hn6P8E3048Fa3ue/jQAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;8&quot;
        title=&quot;&quot;
        src=&quot;/static/347e260d2526e22416d735da1d6ed7dd/dd45a/8.png&quot;
        srcset=&quot;/static/347e260d2526e22416d735da1d6ed7dd/948cf/8.png 138w,
/static/347e260d2526e22416d735da1d6ed7dd/6b2ea/8.png 275w,
/static/347e260d2526e22416d735da1d6ed7dd/dd45a/8.png 550w,
/static/347e260d2526e22416d735da1d6ed7dd/d4c13/8.png 825w,
/static/347e260d2526e22416d735da1d6ed7dd/8bd7c/8.png 845w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;스택 최상단의 두 점(7번과 6번)을 잇고 8번 점을 확인합니다.&lt;br/&gt;
8번 점은 직선의 시계 방향(오른쪽)에 있으므로 스택을 pop합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/5e014aa6a9375ee603418c219a6e0709/bad1b/9.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 48.55072463768116%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABaElEQVR42nVS72+CMBDl//+T/GaiftCobBls0SVEYWWjE/AH0ArlrVctw+maXNpe7969u1enaRoopUB738hX1/W/b399jbrsDj2StW2LFsBxn8N9eUXIc31rTdD5fIaNs4BFUSBN0+5uzSEWBJbvj3gOvpBmOTYsQRzHKMsSUkowxtD2wMjneR5ms1lXzDJ1NA3kuQbZbFEJiZiniPPKsNtpBlEYItllUJq+6o1isVhgMpncMxSiQk1ObaWsUVTyci5OJuCTfcAPU4hGl6A5XQHn8zlGo9E94NNqA6lBoXTVVYi9oEkCbyFHkh1x0DO9tPSbZBk+BNwmGURVGkFMojZNEZkEdocC3zwxBfqJNDfXdTEej82ZNOgA++h9JWkxLcz7lt0A2rflcmkMVyI9lZuHgEqrQCKdRN0xp1ZpTadTDAYDDIdD+L5/U9CxclPw3Wc1QbTXXQy1F0URgiDAer0G59z47Lf5AT8bBOA/tq27AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;9&quot;
        title=&quot;&quot;
        src=&quot;/static/5e014aa6a9375ee603418c219a6e0709/dd45a/9.png&quot;
        srcset=&quot;/static/5e014aa6a9375ee603418c219a6e0709/948cf/9.png 138w,
/static/5e014aa6a9375ee603418c219a6e0709/6b2ea/9.png 275w,
/static/5e014aa6a9375ee603418c219a6e0709/dd45a/9.png 550w,
/static/5e014aa6a9375ee603418c219a6e0709/d4c13/9.png 825w,
/static/5e014aa6a9375ee603418c219a6e0709/bad1b/9.png 841w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;스택 최상단의 두 점(6번과 3번)을 잇고 8번 점을 확인합니다.&lt;br/&gt;
8번 점은 직선의 반시계 방향(왼쪽)에 있으므로 스택에 넣습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/fa7d30a294ccd66df3db9e3df253f047/d52e5/10.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 50.724637681159415%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAKCAYAAAC0VX7mAAAACXBIWXMAAAsTAAALEwEAmpwYAAABkElEQVR42m1SXW+CQBDk//8UH02avjZa0kKsH6ClmAZtVURsIwoFjzuY7h1ioPaSCcfe7ezs7GlFUeAKISqUJUpC9V+gLEq07hHU+Z+YhCYoSYHzCxHgz2zMbBcZF0QmwPMcnM7ru5LsdDohCAIwxhRRfa7VzJSJr9UWq4GFwJ7h03xB4jigWwj3e6RpCrlkklyWZcE0TURRdI1fFRIdgtkUO8PETxzD2x8h09hmjePzE3xvQWpl66TkQjgej2EYBrIsU4qvhNQkBFWPp1MKCEQpU5c4tZLxHGd/g/nDI8KcWGT7vCIcDofo9/uq1ZaHOwasdKrkOogp2ZqvlbokY5iHMeLlEonnUVkonyWBXKPRCLqu33qY5CW+P9bIFh5hgfObg9S2cJxMEL6+w7+/A08SZYtMrD2UhL1eTxG1Wq6mVlQTvpgrqKqgybJTBM8YID1zZUf1GipC13XVYOoiNTRRB6Tkhh8qRl9GBFwULXXb7RadTgfdblcN52bK/4E332dDhdzLoR0OB/Vk5L7p4S/8+QBZC4dJDwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;10&quot;
        title=&quot;&quot;
        src=&quot;/static/fa7d30a294ccd66df3db9e3df253f047/dd45a/10.png&quot;
        srcset=&quot;/static/fa7d30a294ccd66df3db9e3df253f047/948cf/10.png 138w,
/static/fa7d30a294ccd66df3db9e3df253f047/6b2ea/10.png 275w,
/static/fa7d30a294ccd66df3db9e3df253f047/dd45a/10.png 550w,
/static/fa7d30a294ccd66df3db9e3df253f047/d4c13/10.png 825w,
/static/fa7d30a294ccd66df3db9e3df253f047/d52e5/10.png 848w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;모든 점을 확인했다면 스택에는 컨벡스 헐을 구성하는 점들이 존재하게 됩니다!&lt;/p&gt;
&lt;h3&gt;CCW (Counter ClockWise)&lt;/h3&gt;
&lt;p&gt;알고리즘 자체는 크게 어렵지 않은 것 같은데 어떻게 “반시계 방향으로 정렬”을 하고 직선의 “반시계 방향”에 점이 존재하는지 알 수 있을까요?&lt;/p&gt;
&lt;p&gt;이 부분을 해결할 수 있는 것이 바로 CCW입니다.&lt;/p&gt;
&lt;p&gt;CCW는 &lt;strong&gt;평면&lt;/strong&gt; &lt;strong&gt;위에 놓여진 세 점의 방향관계&lt;/strong&gt;를 알 수 있게 해주는 알고리즘으로 벡터의 외적을 이용합니다.&lt;/p&gt;
&lt;p&gt;두 벡터 A,B에 대한 외적의 결과는 두 벡터에 동시에 수직인 벡터입니다. 그렇다면 외적의 결과로 나온 벡터의 크기야 어떻든, &lt;strong&gt;z축에서 +인지 -인지에 따라 A와 B의 방향관계를 알 수 있을 것입니다.&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;벡터 A와 B의 외적은 다음과 같이 구할 수 있습니다. (점 a, b, c는 평면에 존재하므로 z는 모두 0입니다.)&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 399px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/4025354f87ad8f4d5787d84cd5faa9bf/a307d/math.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 16.666666666666664%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAADCAYAAACTWi8uAAAACXBIWXMAAAsTAAALEwEAmpwYAAAAgElEQVR42j2Pyw6FIBBD/f+f1BUmAoLydtObM4tL0oR0pied7b5vpZRUa1WM0f7XdSnnrPd9zQshyHuv3rue5/l76DxPHfuhlJN42xhDCCABQK01rbX0fZ9Bmc05zUPMUSnFfPJkDUgjRAOCtKMBTViiAXPACJ+r2HXOGZQ98gB/0ZblpR/TM6AAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;math&quot;
        title=&quot;&quot;
        src=&quot;/static/4025354f87ad8f4d5787d84cd5faa9bf/a307d/math.png&quot;
        srcset=&quot;/static/4025354f87ad8f4d5787d84cd5faa9bf/948cf/math.png 138w,
/static/4025354f87ad8f4d5787d84cd5faa9bf/6b2ea/math.png 275w,
/static/4025354f87ad8f4d5787d84cd5faa9bf/a307d/math.png 399w&quot;
        sizes=&quot;(max-width: 399px) 100vw, 399px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;오른손 법칙에 의해 외적을 하려는 두 벡터가 이어지는 방향대로 오른손을 감싸면 엄지손가락이 향하는 방향으로 외적이 생성됩니다. 즉 반시계 방향으로 이어진다면 위쪽 방향으로 외적이 생성되고, 시계 방향으로 이어진다면 아래쪽 방향으로 외적이 생성됩니다.&lt;/p&gt;
&lt;p&gt;바꿔말하면, 외적의 z축이 음수라면 두 벡터는 시계 방향으로 이어져있다는 것이고, 양수라면 두 벡터는 반시계 방향으로 이어졌다는 것입니다. (일직선상에 존재한다면 0이 됩니다.)&lt;/p&gt;
&lt;p&gt;A와 B를 이은 직선과 C의 방향 관계를 알고싶다면 벡터AC와 벡터AC의 내적을 구하면 됩니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/68b4f50b082c19d6c537a9b02aceb5d1/f0551/last.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 39.85507246376812%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABM0lEQVR42l1Si26DMAzk//+uVbtpqKxMlPerUB6FkNx82WB0ltyk9vlsX3C01qCN4yj+lJsBY3unGWM2V/P8kmdsPZ1pmlBVFW5RBPfisRJKLViWP18JiR2GAd71C0YIlFKbE0dSh5e6rgX8RFmWaO53NE2DMAxfJqAxTmyaprgLjsaTA3FDO6ExGr10DeMESZLgcHpH+3gIsEbXdZhlvXVC3vthRC9x7/OKQSRibN5J4BDIzmVV29ELmZJdI5GAk7Dzamzw9uEizzNcrj6CMLLYPM/Rtu0PIX+oDQtJaEWXk0CC/ms4yjb2v9Qxx62yLLP1lpDJ8+mM4+GIRNYOgsAS6t8C+qphHMdwXdcSULdB1meeK2+PQvBaaEnU8vKJGG02QhL5vm8frygK++J699rk+Aa1YGxKjH8jmQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;last&quot;
        title=&quot;&quot;
        src=&quot;/static/68b4f50b082c19d6c537a9b02aceb5d1/dd45a/last.png&quot;
        srcset=&quot;/static/68b4f50b082c19d6c537a9b02aceb5d1/948cf/last.png 138w,
/static/68b4f50b082c19d6c537a9b02aceb5d1/6b2ea/last.png 275w,
/static/68b4f50b082c19d6c537a9b02aceb5d1/dd45a/last.png 550w,
/static/68b4f50b082c19d6c537a9b02aceb5d1/d4c13/last.png 825w,
/static/68b4f50b082c19d6c537a9b02aceb5d1/f0551/last.png 862w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;코드&lt;/h3&gt;
&lt;p&gt;&lt;a href=&quot;https://www.acmicpc.net/problem/1753&quot;&gt;[백준] 1708번:볼록껍질&lt;/a&gt; 문제를 통해서 코드를 구현해봤습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;cpp&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;#include &amp;lt;algorithm&amp;gt;
#include &amp;lt;iostream&amp;gt;
#include &amp;lt;stack&amp;gt;

using namespace std;
typedef long long ll;

int n;
pair&amp;lt;ll, ll&amp;gt; point[100001];

bool y_first_cmp(pair&amp;lt;ll, ll&amp;gt; &amp;amp;a, pair&amp;lt;ll, ll&amp;gt; &amp;amp;b)
{
    if (a.second == b.second)
        return a.first &amp;lt; b.first;
    return a.second &amp;lt; b.second;
}

ll ccw(pair&amp;lt;ll, ll&amp;gt; &amp;amp;a, pair&amp;lt;ll, ll&amp;gt; &amp;amp;b, pair&amp;lt;ll, ll&amp;gt; &amp;amp;c)
{
    return a.first * b.second + b.first * c.second + c.first * a.second - b.first * a.second - c.first * b.second -
           a.first * c.second;
}

ll dist(pair&amp;lt;ll, ll&amp;gt; &amp;amp;a, pair&amp;lt;ll, ll&amp;gt; &amp;amp;b)
{
    return (a.first - b.first) * (a.first - b.first) + (a.second - b.second) * (a.second - b.second);
}

bool ccw_cmp(pair&amp;lt;ll, ll&amp;gt; &amp;amp;a, pair&amp;lt;ll, ll&amp;gt; &amp;amp;b)
{
    ll c = ccw(point[0], a, b);
    if (c == 0)
        return dist(point[0], a) &amp;lt; dist(point[0], b);
    return c &amp;gt; 0;
}
int main()
{
    cin &amp;gt;&amp;gt; n;
    ll x, y;
    for (int i = 0; i &amp;lt; n; i++)
    {
        cin &amp;gt;&amp;gt; x &amp;gt;&amp;gt; y;
        point[i] = {x, y};
    }
    // 기준점을 찾기 위해 1차 정렬 (y가 작은 순서. y가 같다면 x가 작은 순서)
    sort(point, point + n, y_first_cmp);
    // 기준 점을 기준으로 반시계 방향으로 나머지 점을 정렬 (일직선상에 있다면 기준점에서 가까운 순서)
    sort(point + 1, point + n, ccw_cmp);
    stack&amp;lt;pair&amp;lt;ll, ll&amp;gt;&amp;gt; st;
    // 첫 두점을 스택에 넣는다.
    st.push(point[0]);
    st.push(point[1]);
    pair&amp;lt;ll, ll&amp;gt; a, b;
    for (int i = 2; i &amp;lt; n; i++)
    {
        // 두 점을 꺼낼 수 있는 동안 반복한다.
        while (st.size() &amp;gt;= 2)
        {
            // 최상단의 두 점을 꺼낸다. 맨 위의 점은 pop한다.
            b = st.top();
            st.pop();
            a = st.top();
            // 최상단의 두 점을 이은 직선이 현재 확인하고 있는 점과 반시계 방향으로 연결되어 있다면 break한다.
            if (ccw(point[i], a, b) &amp;gt; 0)
            {
                // 이 경우 맨위의 점을 pop하면 안되니까 다시 넣어주고 break한다.
                st.push(b);
                break;
            }
        }
        // 현재 확인하고 있는 점을 스택에 넣는다.
        st.push(point[i]);
    }
    cout &amp;lt;&amp;lt; st.size();
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;</content:encoded></item><item><title><![CDATA[리액트로 자체 잔디 심기 기능 구현하기]]></title><description><![CDATA[…]]></description><link>https://klloo.github.io/make-streak/</link><guid isPermaLink="false">https://klloo.github.io/make-streak/</guid><pubDate>Tue, 05 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;이번 프로젝트에서 구현한 기능 중 매일 한 문제씩 랜덤으로 문제를 추천해주는 기능이 있는데요, 매일 해당 문제를 풀었는지 체크해서 잔디를 심어 보여줄 수 있는 기능이 있으면 좋겠다고 생각했습니다.&lt;/p&gt;
&lt;p&gt;처음에는 흔한 기능이라 생각하여 라이브러리나 참고할만한 코드가 있겠지... 하며 안일하게 생각했었는데 웬걸 ...이 기능의 정확한 명칭도 모르겠고 일단 제가 찾아본 결과로는 라이브러리는 커녕 딱히 참고할만한 코드도 없었습니다. 그래서 한 번 직접 구현해보기로 했습니다.&lt;/p&gt;
&lt;h3&gt;분석&lt;/h3&gt;
&lt;p&gt;먼저 제가 이 잔디 기능을 가장 많이 접했던 사이트가 github와 solved.ac이었는데요 먼저 해당 사이트의 잔디가 어떻게 구현되고 있는지 html을 살펴봤습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/6fe329cf20ac3db1f28449dbb05f6ad7/cdf95/solvedac_grass1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 32.608695652173914%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAABYlAAAWJQFJUiTwAAABmUlEQVR42m2R3WvTYBSH+6/3ZjoRP7YbVxVBEZ2wzY8Lce1WQQRBtLqpbaf9SPImaZO8SZq0+Vzz+KYIIng4D79zc56LcxphtCRJctKs+C9Jmm+o56IsyYs1UrgETsh8nhHIlCgqyJY5VVXR+Dn8gTA0qC5VF1Trv1CVpElMni5ZX9YLawVkrofUbSajmNBdEvspRS1cK2H7i+D0fEb3zKPTU3yWtBV1nvT8DcefJK8/evTNFU4KIxExGNr0hjEDLaavpwz0hLGd0Nhta1x/NWb7YErz4USh0XyksfXUYOuJwZV9wdVnJs3HOsfnAUEOuiz4+t3h24VDf+JzNvTU7PHLiGi0ukp4OOXmc4MbRwbb+yoPTHZe2tw6srj9wmZHce1Q8P4ipK5S3XEhHEJrRmBazMc6riaJvBWNB+9M7p6a3Ota3H9r0eoI7rR19k4Eex2D1p/cfaPzYbTYCPO8UoIZUglnUxsx0pgbAWEtlHGGXCriFF/lLIgxHB/hBv9gyQWrrFS6irKslMxXn/ZxTQ9zOiewQ1Zxxm+hK/pUciOOCQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;solvedac grass1&quot;
        title=&quot;&quot;
        src=&quot;/static/6fe329cf20ac3db1f28449dbb05f6ad7/dd45a/solvedac_grass1.png&quot;
        srcset=&quot;/static/6fe329cf20ac3db1f28449dbb05f6ad7/948cf/solvedac_grass1.png 138w,
/static/6fe329cf20ac3db1f28449dbb05f6ad7/6b2ea/solvedac_grass1.png 275w,
/static/6fe329cf20ac3db1f28449dbb05f6ad7/dd45a/solvedac_grass1.png 550w,
/static/6fe329cf20ac3db1f28449dbb05f6ad7/d4c13/solvedac_grass1.png 825w,
/static/6fe329cf20ac3db1f28449dbb05f6ad7/99f37/solvedac_grass1.png 1100w,
/static/6fe329cf20ac3db1f28449dbb05f6ad7/cdf95/solvedac_grass1.png 2106w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/4feef0e28d05b9ce1bab5f756bdac8e9/3c2d4/solvedac_grass2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 28.985507246376812%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABX0lEQVR42l2RW2/TQBCF8/9/BY+8UgSiAlG1iDalRVCSQi8ksWPXt8beXXu967WdfmyNxAMjHY3m5ZszZ2ZhFPOQpBhr6Zz7Tz3aWHRrpnkcR56A/dCTBQXJJkFEK7JQIBKF0Y5ZkmZs44hGG4xxtO1fNY1D6w5ZScqqpK5bD9zDBBwpt4+oosRWBVpo2kqhKstMyMY73HGzKDl5U3J8IDl+pTh7p/nyseXbvOb7qdcn7cF7Cgup6FkuMm7ucoJgy/1asQoqVknrgUpw9TXm/GjHyWvBwYsdhy8F5x8Mn98a5u8t80PH5VGHUiPO32zsQBzkbNcJeRgSbSRprJC1d1jrmlvvbnHht/xquTpruL5o+b103P1wrK4dPy8Nt0szgZ7rqR/I1ynpKkaE9+TeXRVLrPbAruvphwHXu6mbziCU/CdZKyopqJtmesoEHAcKn2EeZsiHDY+Rzy+rcbbnD6GLwKd9tvxBAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;solvedac grass2&quot;
        title=&quot;&quot;
        src=&quot;/static/4feef0e28d05b9ce1bab5f756bdac8e9/dd45a/solvedac_grass2.png&quot;
        srcset=&quot;/static/4feef0e28d05b9ce1bab5f756bdac8e9/948cf/solvedac_grass2.png 138w,
/static/4feef0e28d05b9ce1bab5f756bdac8e9/6b2ea/solvedac_grass2.png 275w,
/static/4feef0e28d05b9ce1bab5f756bdac8e9/dd45a/solvedac_grass2.png 550w,
/static/4feef0e28d05b9ce1bab5f756bdac8e9/d4c13/solvedac_grass2.png 825w,
/static/4feef0e28d05b9ce1bab5f756bdac8e9/99f37/solvedac_grass2.png 1100w,
/static/4feef0e28d05b9ce1bab5f756bdac8e9/3c2d4/solvedac_grass2.png 2092w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;solved.ac는 svg를 이용하여 각 네모칸을 그려주고 있었고&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/80e36aaa23ee40b2b5c895ea28cfe719/62b00/github_grass1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 22.46376811594203%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAECAYAAACOXx+WAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA/ElEQVR42k2NSW+CUACE+f9/ops99da0XnprrLS2TVTcl0R4LEYeoGwiPviKnjrJZGYyyYzm+wFxnHEqCqIoIs9z/qOua1RVXb06nYmcHeYmwXUypJ8gZcbhcCRPS8pCockgIMuPFKeSQ5ISpxlnVVOqirw4kTadUuo6WNUQbgM8ESGsBMeSOGKPJXI8N2EfxGh3HcHNu8lDx+a+YevDpdX1eNRdbpv89OMSNKdCCFzPZWKs0Dtj9O4CXV/T+5zz25vx/TVjZFho7aHkZeDTHkgu/qKvTb7wub/jbSoJwxDbtvG2HqulSb+/wTBMxuMNi8mM9XTOaLhkvnD4A9uDJPKH+4rBAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;github grass1&quot;
        title=&quot;&quot;
        src=&quot;/static/80e36aaa23ee40b2b5c895ea28cfe719/dd45a/github_grass1.png&quot;
        srcset=&quot;/static/80e36aaa23ee40b2b5c895ea28cfe719/948cf/github_grass1.png 138w,
/static/80e36aaa23ee40b2b5c895ea28cfe719/6b2ea/github_grass1.png 275w,
/static/80e36aaa23ee40b2b5c895ea28cfe719/dd45a/github_grass1.png 550w,
/static/80e36aaa23ee40b2b5c895ea28cfe719/d4c13/github_grass1.png 825w,
/static/80e36aaa23ee40b2b5c895ea28cfe719/99f37/github_grass1.png 1100w,
/static/80e36aaa23ee40b2b5c895ea28cfe719/62b00/github_grass1.png 2708w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/07090eefbedb8696587fa09105dfb39c/b6425/github_grass2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 5.797101449275362%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAABCAYAAADeko4lAAAACXBIWXMAABYlAAAWJQFJUiTwAAAASElEQVR42i3KOw6AIBBAQe9/SQsTNHwMC+4a0PCksJpmlj0KLmVSuQlihKy/hhfFF+XIFWsP1gfaBvbCmRS3ejY3T6yk+eXqfBGNTGhI2l/tAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;github grass2&quot;
        title=&quot;&quot;
        src=&quot;/static/07090eefbedb8696587fa09105dfb39c/dd45a/github_grass2.png&quot;
        srcset=&quot;/static/07090eefbedb8696587fa09105dfb39c/948cf/github_grass2.png 138w,
/static/07090eefbedb8696587fa09105dfb39c/6b2ea/github_grass2.png 275w,
/static/07090eefbedb8696587fa09105dfb39c/dd45a/github_grass2.png 550w,
/static/07090eefbedb8696587fa09105dfb39c/d4c13/github_grass2.png 825w,
/static/07090eefbedb8696587fa09105dfb39c/99f37/github_grass2.png 1100w,
/static/07090eefbedb8696587fa09105dfb39c/b6425/github_grass2.png 2336w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;github는 table태그를 사용해서 행과 열을 가지는 테이블 형태로 요소들을 그려주고 있었습니다.&lt;/p&gt;
&lt;p&gt;이 잔디 기능에서는 보통&lt;/p&gt;
&lt;p&gt;1 4 7 10&lt;br/&gt;
2 5 8 ...&lt;br/&gt;
3 6 9&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;이런 순서로 날짜가 진행됩니다. (1이 가장 오래된 날짜) 제가 생각하기로는 이 순서를 관리하기 위해서는 행과 열로 이루어진 table태그 보다는 각각 요소를 svg로 따로 넣어주는 편이 구현이 쉽겠다고 판단해서 solved.ac를 따라가기로 했습니다.&lt;/p&gt;
&lt;h3&gt;구현&lt;/h3&gt;
&lt;h4&gt;스트릭 정보 가공&lt;/h4&gt;
&lt;p&gt;서버에서 받아오는 스트릭 정보는 아래와 같습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/20e4f9efcda8fd19a3b95f421d3b5937/a4262/streakinfo.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 27.536231884057973%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABCElEQVR42lWQi46EIAxF/f/Pm82OOj5REGFUfCUmJnqXdpZNlqSBvk4vjZRUUEqhrmv0vUHTNGiVRiUkzHuCVB3n6lqg6zSmaeJ66fucc7DWwhiDbdtAJxq7AQRN05e3lIFlUSLPC373fc93HCfIshxlWXlgh+K3hsAEFKL5ANdhgfHKsjxHkhCw5SQ1SCkZRg1xHHOeoMMwoKoqBratxDiOPOg8T0SznWG04cIkSSA8gIDfz6f/Iikp/DcdHo+vvxoC0gqCYudmlH7Avu+IdrdhHEY/iZQJVmPtm79Ck2lf67qyolCzLAvHybTWvD9aw3EciO77RrDruvimE3yy4Af7+Ne/WIj/AD5Pvw6hTl5tAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;streakinfo&quot;
        title=&quot;&quot;
        src=&quot;/static/20e4f9efcda8fd19a3b95f421d3b5937/dd45a/streakinfo.png&quot;
        srcset=&quot;/static/20e4f9efcda8fd19a3b95f421d3b5937/948cf/streakinfo.png 138w,
/static/20e4f9efcda8fd19a3b95f421d3b5937/6b2ea/streakinfo.png 275w,
/static/20e4f9efcda8fd19a3b95f421d3b5937/dd45a/streakinfo.png 550w,
/static/20e4f9efcda8fd19a3b95f421d3b5937/a4262/streakinfo.png 814w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;해결한 문제의 번호와 문제를 해결한 날짜, 그리고 그 날에 해당 문제를 풀었는지 여부가 주어집니다.&lt;/p&gt;
&lt;p&gt;저는 먼저 이 객체 배열을 날짜를 키, 다른 부가 정보를 값으로 가지는 객체로 가공을 했습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 스트릭 정보 생성. 스트릭의 날짜를 key값으로 가지는 객체를 생성한다.
const streakInfo = randomStreak.reduce((result, item) =&amp;gt; {
 result[item.date] = item;
 return result;
}, {});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그리고 maxStreak을 스트릭 컴포넌트의 props로 받아서 오늘 기준으로 maxStreak전날까지의 모든 날짜 정보를 가지는 객체 배열을 생성했습니다.
배열을 만들면서 위에서 만든 객체를 활용하여 그 날짜에 문제 해결 여부를 함께 담아줬습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// maxStreak 개수 만큼 스트릭을 생성한다.
// 스트릭 정보에는 날짜, x,y좌표, 그 날짜에 해결했는지 여부, 스트릭 프리즈 여부가 포함된다.
setStreakList(
 [...Array(maxStreak)].map((_, i) =&amp;gt; {
  /**
   * 오늘 날짜에서 i번째 이전 날짜를 반환한다.
   */
  const getPreviousDate = useCallback((i) =&amp;gt; {
   const today = new Date();
   // 오전 6시 기준으로 오늘이 나뉨. 오전 6시 이전이라면 어제를 오늘로 친다.
   if (today.getHours() &amp;lt; 6) {
    today.setDate(today.getDate() - 1);
   }
   const previousDate = new Date(today);
   previousDate.setDate(today.getDate() - i);
   return previousDate;
  }, []);

  // maxStreak전 날 부터 오늘 날짜 까지 데이터 생성
  const streakDate = moment(getPreviousDate(maxStreak - i - 1));
  const formatDate = moment(streakDate).format(&amp;#39;YYYY-MM-DD&amp;#39;);
  // streakInfo 객체에 해당 값이 있고 해당 값의 grassInfo가 true라면 그 날 푼 것임
  const solved = streakInfo.hasOwnProperty(formatDate) &amp;amp;&amp;amp; streakInfo[formatDate].grassInfo;
  // 스트릭 프리즈
  const isFreeze = solved &amp;amp;&amp;amp; streakInfo[formatDate].problemId == 0;
  return {
   date: formatDate,
   x: parseInt(i / line) * 20 + 1,
   y: (i % line) * 20 + 1,
   solved: solved,
   isFreeze: isFreeze,
  };
 }),
);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;하루의 기준은 자정이 아닌 오전 6시로 설정을 해주었고, solved.ac를 참고하여 스트릭 프리즈 기능도 함께 개발했기 때문에 그 날짜에 데이터는 있으나, 푼 문제의 번호가 0번이라면 스트릭 프리즈가 활성된 것으로 판단하였습니다.&lt;/p&gt;
&lt;p&gt;각 x좌표와 y좌표는&lt;/p&gt;
&lt;p&gt;1 4 7 10&lt;br/&gt;
2 5 8 ...&lt;br/&gt;
3 6 9&lt;br/&gt;&lt;/p&gt;
&lt;p&gt;이 순서로 설정해줬습니다. (곱해주는 20은 잔디 한 칸의 크기와 공백을 고려한 크기 이고, line변수는 스트릭을 몇 줄 만들건지에 관한 변수입니다.)&lt;/p&gt;
&lt;p&gt;이렇게 설정을하면 맨 오른쪽 아래 잔디는 항상 오늘이 됩니다. 다른 사이트들의 스트릭 기능 처럼 매일 새로운 잔디가 순서대로 붙여지는 것이 아닌 맨 오른쪽 아래에 오늘의 잔디가 하나 생기면 그 전의 것들이 하나씩 밀려나는 방식으로 구현이 됩니다.&lt;/p&gt;
&lt;h4&gt;잔디 그리기&lt;/h4&gt;
&lt;p&gt;이제 위에서 가공한 정보를 바탕으로 잔디를 그려주기만 하면됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;svg height={height} width={width} overflow=&amp;quot;auto&amp;quot;&amp;gt;
 {streakList.map((streak, i) =&amp;gt; (
  &amp;lt;React.Fragment key={`${streak.date}-fragment`}&amp;gt;
   &amp;lt;StreakIcon streak={streak} /&amp;gt;
  &amp;lt;/React.Fragment&amp;gt;
 ))}
&amp;lt;/svg&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;StreakIcon 컴포넌트는 아래와 같습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const StreakIcon = ({ streak }) =&amp;gt; {
 return (
  &amp;lt;rect
   width=&amp;quot;18&amp;quot;
   height=&amp;quot;18&amp;quot;
   x={streak.x}
   y={streak.y}
   rx=&amp;quot;5&amp;quot;
   fill={streak.solved ? (streak.isFreeze ? &amp;#39;var(--color-toggle)&amp;#39; : &amp;#39;var(--color-checked)&amp;#39;) : &amp;#39;var(--color-unchecked)&amp;#39;}
  /&amp;gt;
 );
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;각 네모 한 칸은 rect 태그를 사용하였고 좌표는 위에서 계산된 잔디 별 좌표를 사용했습니다. 또 풀었는지 안풀었는지, 스트릭 프리즈가 적용됐는지 여부에 따라 다른색이 적용되도록 하였습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/93ad7a969e6cad1eb17dcabb896b2a37/9cab2/streak1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 29.71014492753623%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA0klEQVR42qWQvWrDMBRG89x5iw5dM2Zqp059inRocGyMobL8G4NjRaqwIT7JlcmWDKUXDldwpSN9WvV9TxRFpGlKURTEcUyWZVRVRZIkjOPIX2rlvacsS+q6puu6IGqaJqy11hhjsNY+5GzPjG4iHzI608LlJnTOked5eJ0gQukik4tk9hhFoUu+f77YHl55O2wYfL8I74elC88lC7JHaUWjj3ym77zs13wk20UokZVSAZHfeRZTCHNn+XWeymii047BnpbI0zTRtm34t3me+W9dAczxxObGtMViAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;streak1&quot;
        title=&quot;&quot;
        src=&quot;/static/93ad7a969e6cad1eb17dcabb896b2a37/dd45a/streak1.png&quot;
        srcset=&quot;/static/93ad7a969e6cad1eb17dcabb896b2a37/948cf/streak1.png 138w,
/static/93ad7a969e6cad1eb17dcabb896b2a37/6b2ea/streak1.png 275w,
/static/93ad7a969e6cad1eb17dcabb896b2a37/dd45a/streak1.png 550w,
/static/93ad7a969e6cad1eb17dcabb896b2a37/d4c13/streak1.png 825w,
/static/93ad7a969e6cad1eb17dcabb896b2a37/9cab2/streak1.png 864w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;툴팁 기능&lt;/h4&gt;
&lt;p&gt;스트릭 기능은 대충 완성이 되었지만 해당 잔디가 어느 날짜의 잔디인지 알려면 마우스 오버 시 보여지는 툴팁이 필요합니다.&lt;/p&gt;
&lt;p&gt;처음에는 &lt;a href=&quot;https://www.npmjs.com/package/react-tooltip&quot;&gt;react-tooltip&lt;/a&gt; 패키지를 사용하려했으나 ... 적용이 안돼서 찾아보니 svg에는 적용이 안된다고 합니다. svg에 적용되는 툴팁 라이브러리가 있긴 했으나 썩 맘에 들지않아 툴팁도 직접 구현하게 되었습니다.&lt;/p&gt;
&lt;p&gt;svg요소 내부에 툴팁을 띄워야 했으므로 툴팁도 직접 그려줬습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;function StreakTooltip({ streak }) {
 return (
  &amp;lt;g&amp;gt;
   &amp;lt;rect
    x={streak.x + 85 &amp;gt; 550 ? streak.x - 88 : streak.x + 22}
    y={streak.y}
    width={85}
    height={20}
    rx={5}
    fill=&amp;quot;#2a2a2a&amp;quot;
   /&amp;gt;
   &amp;lt;text x={streak.x + 85 &amp;gt; 550 ? streak.x - 12 : streak.x + 98} y={14 + streak.y} fontSize={12} fill=&amp;quot;white&amp;quot;&amp;gt;
    {streak.date}
   &amp;lt;/text&amp;gt;
  &amp;lt;/g&amp;gt;
 );
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;마우스 오버된 스트릭을 props로 전달하면 해당 위치의 스트릭을 잘 계산하여 ... 적절한 위치에 툴팁을 띄워줬습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/18c399fe746f515c9d3444bf3c04aea7/ad12c/tooltip1.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 29.71014492753623%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA80lEQVR42pVRy4qDQBD0K/ML+YA95BrIZW6bmNfuKV/gyR8I5L43ZRW8+BwVD75Qs9Fae4JiIATSUFR3Q1d3zUhRFEHTNJimCdd1oes6LMsSuWEYqKoKFF3XYRpUTzGEVJYlgiAA5xxJkgimJZT7vo80TZHnuUBRFIKbpnkQiq8+eOYCf71glmXiGhr2PG9k6hE7jjPCtm2xUFVVyLKM3X6L4/ob7LTE5rxE0IuOgnQl8XR4Kjb0wjCEoihgjGH9ucFi9YH5YYavC+sFHUhkYxgg+1S/wmC5bdv+IYH0luC3+kFc8Lvluq6FDbrwnXj2IfQp/5/WvKhxm9tuAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;tooltip1&quot;
        title=&quot;&quot;
        src=&quot;/static/18c399fe746f515c9d3444bf3c04aea7/dd45a/tooltip1.png&quot;
        srcset=&quot;/static/18c399fe746f515c9d3444bf3c04aea7/948cf/tooltip1.png 138w,
/static/18c399fe746f515c9d3444bf3c04aea7/6b2ea/tooltip1.png 275w,
/static/18c399fe746f515c9d3444bf3c04aea7/dd45a/tooltip1.png 550w,
/static/18c399fe746f515c9d3444bf3c04aea7/d4c13/tooltip1.png 825w,
/static/18c399fe746f515c9d3444bf3c04aea7/ad12c/tooltip1.png 856w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;
&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/936e6bca32febbbcf598427df27fc8b2/f0551/tooltip2.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 30.434782608695656%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABCklEQVR42pWQvW+CUBTF/b9ZTdwZMW6dmtqNpOnkxNTBJtJI6gACIhTDV3kPlfqr7xmHfgztSX7JHW7OvecMyrLEdV08zyMMQxaLhZ7jONazlBKl0+nEXzTouo7tdkuSJBRFQdM02uRwONC2raaqqi/Uda2pqhJZ71ntXkiKGPqzoRCC9XpNmqY4joNlWYxGI4bDIYZhYNu2Pqh2VAJFFEWEUcgm2vDsP3GzNLldWhQivxiqhSzLmM/nTKdTJpMJ4/EY0zSZzWb6+5+G5yeiNx5X95iuwcPrHY2sLpGDIMD3fdT8vavj8Yg6ekXVoRBS0Mk9uzbDrz3eRQMf58h93+vu8jzXZr/xH30C/xa89gAbvQwAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;tooltip2&quot;
        title=&quot;&quot;
        src=&quot;/static/936e6bca32febbbcf598427df27fc8b2/dd45a/tooltip2.png&quot;
        srcset=&quot;/static/936e6bca32febbbcf598427df27fc8b2/948cf/tooltip2.png 138w,
/static/936e6bca32febbbcf598427df27fc8b2/6b2ea/tooltip2.png 275w,
/static/936e6bca32febbbcf598427df27fc8b2/dd45a/tooltip2.png 550w,
/static/936e6bca32febbbcf598427df27fc8b2/d4c13/tooltip2.png 825w,
/static/936e6bca32febbbcf598427df27fc8b2/f0551/tooltip2.png 862w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이런식으로 오른쪽에 공간이 없다면 왼쪽에 그려주고, 그 외에는 모두 오른쪽에 그려주도록 계산한 내용입니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/ea38b29b9de26d3a8ca57ec3d3eeae74/1e088/hide_tooltip.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 31.15942028985507%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAAAw0lEQVR42qWRSwqEMBBEc/+19/ACHkEQxYW4iRr//yj4WWgNHVEcmYGBCTyoJt1Fp8KyLINt2/B9H1EUwXEccM4RBAFc18WyLPjl7PuuYNM0oSgKVFWFpmlQliXqulY6z3O0bQspJfq+v+i67k3T/TzPh+EwDGqzOI4vhBCKp77XBM2laQrLsqBpGgzDABvHEUmSgJ5+b37yNDsNadbzPOi6DtM0D8MwDFUDrU1QDJ/0t3pdV2zbprJkFDplRvxzzk95Adt4xQrt/hPHAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;hide tooltip&quot;
        title=&quot;&quot;
        src=&quot;/static/ea38b29b9de26d3a8ca57ec3d3eeae74/dd45a/hide_tooltip.png&quot;
        srcset=&quot;/static/ea38b29b9de26d3a8ca57ec3d3eeae74/948cf/hide_tooltip.png 138w,
/static/ea38b29b9de26d3a8ca57ec3d3eeae74/6b2ea/hide_tooltip.png 275w,
/static/ea38b29b9de26d3a8ca57ec3d3eeae74/dd45a/hide_tooltip.png 550w,
/static/ea38b29b9de26d3a8ca57ec3d3eeae74/d4c13/hide_tooltip.png 825w,
/static/ea38b29b9de26d3a8ca57ec3d3eeae74/1e088/hide_tooltip.png 840w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;하지만 이렇게 하니.. 스크롤을 넘기면 보여지는 부분에서는 오른쪽에 공간이 없음에도 그대로 오른쪽에 그려지도록 되고 있었습니다.
이부분은 개선이 필요해보이는 사항이나 어떻게 개선할지 아이디어도 떠오르지 않았고 스크롤을 넘기면 볼 수 있으므로 일단은 그냥 뒀습니다ㅜㅜ&lt;/p&gt;
&lt;p&gt;어떤 스트릭에 마우스 오버를 했는지 판단하기 위한 코드도 추가를 했습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;svg height={height} width={width} overflow=&amp;quot;auto&amp;quot;&amp;gt;
 {streakList.map((streak, i) =&amp;gt; (
  &amp;lt;React.Fragment key={`${streak.date}-fragment`}&amp;gt;
   {/* 마우스 오버했는지 여부, 마우스를 오버하면 해당 스트릭의 인덱스를 저장해둔다. */}
   &amp;lt;StreakIcon
    isHovering={hoveringStreakIdx == i}
    onMouseEnter={() =&amp;gt; {
     setHoveringStreakIdx(i);
    }}
    onMouseOut={() =&amp;gt; {
     setHoveringStreakIdx(-1);
    }}
    streak={streak}
   /&amp;gt;
  &amp;lt;/React.Fragment&amp;gt;
 ))}
 {/* 툴팁 */}
 {hoveringStreakIdx != -1 &amp;amp;&amp;amp; &amp;lt;StreakTooltip streak={streakList[hoveringStreakIdx]} /&amp;gt;}
&amp;lt;/svg&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const StreakIcon = ({ isHovering, streak, onMouseEnter, onMouseOut }) =&amp;gt; {
 // 마우스 enter, out시 이벤트를 전달하고 마우스 오버 여부에 따라 윤곽선을 그려준다.
 return (
  &amp;lt;rect
   width=&amp;quot;18&amp;quot;
   height=&amp;quot;18&amp;quot;
   x={streak.x}
   y={streak.y}
   rx=&amp;quot;5&amp;quot;
   fill={streak.solved ? (streak.isFreeze ? &amp;#39;var(--color-toggle)&amp;#39; : &amp;#39;var(--color-checked)&amp;#39;) : &amp;#39;var(--color-unchecked)&amp;#39;}
   strokeWidth=&amp;quot;2.5&amp;quot;
   stroke={isHovering ? &amp;#39;#000000&amp;#39; : &amp;#39;transparent&amp;#39;}
   onMouseEnter={onMouseEnter}
   onMouseOut={onMouseOut}
  /&amp;gt;
 );
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/f444864352f22cc82ad03c0a22f338f8/33e10/tada.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 30.434782608695656%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABBklEQVR42nVQy0rDUBTMZ7sKWWRXF7rwAxKIi2xdBkQQVJJ1EbmJktfNQ9KS501akrHnCgVrOzDMfRyGmaNUVQXGGMIwRJqm8H0fSZKAc44gCDCOIwjLsvzjOSht2x4NiqKQ5zzPUZYloihCXdcYhgHTNP0xmucZYhTYDXtUXYmi5cD+YNh1nUyWZZk0JdKdjOktjmOpruvCNE1YlgXDMGDbNjzXgx8yPDAL9+93SLfRb0JKQkakp6RVUHLHcaBpGnRdh6qqWF2v8Pr8hpfgETfrK5jrW3xtPqD0fX9MR/VO2TSNVJqj6kQhhNSmbsG3MbzvJ0SbT2B3qEwftDNKcmnRl3Bu/geLLru/57WSqQAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;tada&quot;
        title=&quot;&quot;
        src=&quot;/static/f444864352f22cc82ad03c0a22f338f8/dd45a/tada.png&quot;
        srcset=&quot;/static/f444864352f22cc82ad03c0a22f338f8/948cf/tada.png 138w,
/static/f444864352f22cc82ad03c0a22f338f8/6b2ea/tada.png 275w,
/static/f444864352f22cc82ad03c0a22f338f8/dd45a/tada.png 550w,
/static/f444864352f22cc82ad03c0a22f338f8/d4c13/tada.png 825w,
/static/f444864352f22cc82ad03c0a22f338f8/33e10/tada.png 844w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이렇게 해서 자체 잔디심기 기능을 완성했습니다!&lt;/p&gt;</content:encoded></item><item><title><![CDATA[세션 기반 인증과 토큰 기반 인증]]></title><description><![CDATA[개인 프로젝트를 진행하며 로그인 기능을 구현했던 과정을 기록해보려고 합니다. 백엔드 개발자와 협의하여 로그인은 JWT…]]></description><link>https://klloo.github.io/session-jwt/</link><guid isPermaLink="false">https://klloo.github.io/session-jwt/</guid><pubDate>Mon, 04 Sep 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;개인 프로젝트를 진행하며 로그인 기능을 구현했던 과정을 기록해보려고 합니다.&lt;/p&gt;
&lt;p&gt;백엔드 개발자와 협의하여 로그인은 JWT를 사용하여 구성하기로 했는데 토큰 방식의 로그인에 개념은 어렴풋이 알고 있었지만 막상 바로 적용하려 하니 어려움이 있어서 먼저 해당 개념에 대해 공부를 했습니다.&lt;/p&gt;
&lt;h2&gt;로그인 방식&lt;/h2&gt;
&lt;p&gt;로그인을 구성하는 방식은 크게 쿠키와 세션을 사용하는 방식과 토큰 기반의 인증 방식으로 나뉩니다.&lt;/p&gt;
&lt;h3&gt;세션 기반 인증&lt;/h3&gt;
&lt;p&gt;세션 기반 인증 방식을 이해하기 위해서는 먼저 쿠키와 세션에 대해 알아야 합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;쿠키&lt;/strong&gt;란 서버에서 사용자의 웹브라우저에 저장하는 작은 데이터 조각입니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/20ef8755197c895185c2fd7c405fe9b0/29b94/cookie.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 81.15942028985506%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHcVoLAD//EABkQAAEFAAAAAAAAAAAAAAAAABABESIxQf/aAAgBAQABBQLXC3If/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFxAAAwEAAAAAAAAAAAAAAAAAABAxAf/aAAgBAQAGPwIuqP8A/8QAGxAAAgIDAQAAAAAAAAAAAAAAAREhMQAQYXH/2gAIAQEAAT8hPcLEVXo0ykBV4ISjr//aAAwDAQACAAMAAAAQ88//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAdEAACAgIDAQAAAAAAAAAAAAABEQAhMUFRgaHw/9oACAEBAAE/EDIFro+qFNCA5yeQYgPJYE9cQHWnuu4GrzP/2Q==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;cookie&quot;
        title=&quot;&quot;
        src=&quot;/static/20ef8755197c895185c2fd7c405fe9b0/d7854/cookie.jpg&quot;
        srcset=&quot;/static/20ef8755197c895185c2fd7c405fe9b0/a81b0/cookie.jpg 138w,
/static/20ef8755197c895185c2fd7c405fe9b0/35f54/cookie.jpg 275w,
/static/20ef8755197c895185c2fd7c405fe9b0/d7854/cookie.jpg 550w,
/static/20ef8755197c895185c2fd7c405fe9b0/0ea46/cookie.jpg 825w,
/static/20ef8755197c895185c2fd7c405fe9b0/29b94/cookie.jpg 897w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;사용자가 웹사이트에 접근하여 HTTP 요청을 하면 서버는 쿠키를 생성하고 정보를 담아 HTTP 응답을 돌려줄 때, 같이 클라이언트에게 돌려줍니다.
넘겨받은 쿠키는 클라이언트가 가지고 있다가 다시 서버에 요청할 때 요청과 함께 쿠키를 전송합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;세션&lt;/strong&gt;이란 일정 시간 동안 같은 사용자로부터 들어오는 요구들을 하나의 상태로 보고, 그 상태를 유지시키는 기술입니다.
여기서 일정 시간이란 클라이이언트가 웹서버에 연결된 순간부터 웹 브라우저를 닫아 서버와의 HTTP 통신을 끝낼 때 까지의 기간을 의미합니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/8942b4f93242e9f2ba653f1e3df769a8/bb3bf/session.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 68.84057971014492%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdxUixB//8QAGhAAAgIDAAAAAAAAAAAAAAAAAAEQERIxQf/aAAgBAQABBQLtw0Yi1//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABcQAAMBAAAAAAAAAAAAAAAAAAAQMUH/2gAIAQEABj8CNVKv/8QAGRABAAMBAQAAAAAAAAAAAAAAAQARIYFx/9oACAEBAAE/IV0W8mXeKg2DVRFdE9IKBP/aAAwDAQACAAMAAAAQUM//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAACAgMBAQAAAAAAAAAAAAABEQAhMUFhcdH/2gAIAQEAAT8QNaKFBYjFOgW+Jdhg0ciUoCEhrsCePJbBKCZzP//Z&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;session&quot;
        title=&quot;&quot;
        src=&quot;/static/8942b4f93242e9f2ba653f1e3df769a8/d7854/session.jpg&quot;
        srcset=&quot;/static/8942b4f93242e9f2ba653f1e3df769a8/a81b0/session.jpg 138w,
/static/8942b4f93242e9f2ba653f1e3df769a8/35f54/session.jpg 275w,
/static/8942b4f93242e9f2ba653f1e3df769a8/d7854/session.jpg 550w,
/static/8942b4f93242e9f2ba653f1e3df769a8/0ea46/session.jpg 825w,
/static/8942b4f93242e9f2ba653f1e3df769a8/ddced/session.jpg 1100w,
/static/8942b4f93242e9f2ba653f1e3df769a8/bb3bf/session.jpg 1132w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;클라이언트가 서버에 요청을 보내면 서버에서는 요청헤더(쿠키)를 확인하고 세션 ID가 있는지 확인합니다.
요청에 세션 ID가 없다면 서버에서는 세션 객체를 생성하여 정보를 저장한 뒤 응답을 보낼 때 쿠키에 세션 ID를 담아서 보냅니다.
클라이언트는 응답에서 받은 세션 쿠키(세션 ID 값)를 저장해두고, 매번 해당 서버에 요청을 보낼 때마다 세션 쿠키를 함께 보내서 자신이 누구인지 인증하고 세션 쿠키는 브라우저가 종료되면 삭제됩니다.&lt;/p&gt;
&lt;h4&gt;그래서 세션 기반 인증 방식이란?&lt;/h4&gt;
&lt;p&gt;사용자의 인증 정보가 서버의 세션 저장소에 저장되는 방식입니다.&lt;/p&gt;
&lt;p&gt;사용자가 로그인을 하면, 해당 인증 정보를 서버의 세션 저장소에 저장하고, 사용자에게는 세션ID를 발급하여 브라우저에 쿠키 형태로 저장합니다.&lt;/p&gt;
&lt;p&gt;인증 절차를 마친 후 클라이언트는 요청마다 Cookie 헤더에 세션ID를 서버로 전송합니다. 그러면 서버가 세션ID에 해당하는 세션 정보가 세션 저장소에 존재하는지 확인하여 해당 클라이언트를 인증된 클라이언트로 판단하는 것입니다.&lt;/p&gt;
&lt;h4&gt;장단점은?&lt;/h4&gt;
&lt;p&gt;서버에서 클라이언트의 상태를 유지하고 있으므로, 사용자의 로그인 여부 확인이 용이하고, 클라이언트가 임의로 정보를 변경시키더라도 서버에서 클라이언트의 상태 정보를 가지고 있으므로 상대적으로 안전하다는 장점이 있습니다.&lt;/p&gt;
&lt;p&gt;하지만 서버에서 클라이언트의 상태를 모두 유지하고 있어야 하므로, 클라이언트 수에 따른 메모리나 DB에 부하가 심하다는 단점이 있습니다. 세션 용 DB를 사용하는 방법도 있지만 추후 서버를 확장하는 상황에서 서버간에 세션을 공유하는 방식도 복잡해집니다.
또한 웹 브라우저에서 세션 관리에 사용하는 쿠키는 단일 도메인에서만 작동하도록 설계되어 CORS 방식을 사용할 때 쿠키 및 세션 관리가 어려워진다는 단점도 있습니다.&lt;/p&gt;
&lt;h3&gt;토큰 기반 인증&lt;/h3&gt;
&lt;p&gt;토큰 기반 인증은 인증 정보를 클라이언트가 직접 가지고 있는 방식입니다. 이때 인증 정보는 토큰의 형태로 브라우저의 로컬 스토리지 또는 쿠키에 저장됩니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/a95575ea0a1a0bd12da6321edfcbcad5/67d3c/token.jpg&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 65.21739130434783%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdyQsD//xAAYEAEAAwEAAAAAAAAAAAAAAAABABAxEf/aAAgBAQABBQJ02JOV/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFxAAAwEAAAAAAAAAAAAAAAAAABAxQf/aAAgBAQAGPwI1Uq//xAAbEAACAwADAAAAAAAAAAAAAAABMQARQRAhYf/aAAgBAQABPyEuwsrJ6JvFhZQU1Ap//9oADAMBAAIAAwAAABAzD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB4QAQADAAAHAAAAAAAAAAAAAAEAESEQMUFRYbHB/9oACAEBAAE/EE7BNHY3D4A+8FZoGlHuZtcrnBQLWurP/9k=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;token&quot;
        title=&quot;&quot;
        src=&quot;/static/a95575ea0a1a0bd12da6321edfcbcad5/d7854/token.jpg&quot;
        srcset=&quot;/static/a95575ea0a1a0bd12da6321edfcbcad5/a81b0/token.jpg 138w,
/static/a95575ea0a1a0bd12da6321edfcbcad5/35f54/token.jpg 275w,
/static/a95575ea0a1a0bd12da6321edfcbcad5/d7854/token.jpg 550w,
/static/a95575ea0a1a0bd12da6321edfcbcad5/0ea46/token.jpg 825w,
/static/a95575ea0a1a0bd12da6321edfcbcad5/ddced/token.jpg 1100w,
/static/a95575ea0a1a0bd12da6321edfcbcad5/67d3c/token.jpg 1131w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;사용자가 아이디와 비밀번호를 입력하고 서버로 요청을 보내면 서버는 db에서 회원을 조회하고 등록된 사용자라면 토큰을 생성하여 클라이언트에 토큰과 함께 응답을 보냅니다.
응답이 성공적으로 왔다면 클라이언트는 이후 인증이 필요한 모든 요청에 해당 토큰을 Authorization헤더에 실어 보냅니다.
그러면 서버는 요청 헤더로 전달받은 토큰을 검증하고 권한이 있는 사용자라고 판단하면 요청된 데이터를 응답해 주는 것입니다.&lt;/p&gt;
&lt;p&gt;하지만 이 때 한가지 주의 사항이 있습니다. 토큰은 발급 시 유효기간 동안 되돌릴 수 없고 탈취당할 경우 토큰에는 인증 정보가 모두 담겨있으므로 위험합니다.
이를 해결하기 위해 서버에서는 Access token과 Refresh token 두개의 토큰을 발행 합니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Access Token&lt;/strong&gt;: 클라이언트 쪽에서 요청 헤더에 담아 보내는 토큰 입니다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;Refresh Token&lt;/strong&gt;: Access Token이 만료되거나 잘못된 토큰일 경우 Refresh Token을 사용해 유저를 검증합니다. 만약 Refresh Token을 검증하여 인증된 유저일 경우 Access Token을 재발행 해줍니다.&lt;/p&gt;
&lt;p&gt;결론적으로 Access Token의 유효기간을 짧게 설정하고 Refresh Token의 유효기간을 길게 설정하여 Access Token 만료시 Refresh Token을 검증하여 Access Token을 재발행 해주는 것으로 보안적으로 안전하게 유저 인증을 관리 할 수 있습니다.&lt;/p&gt;
&lt;h4&gt;장단점은?&lt;/h4&gt;
&lt;p&gt;클라이언트가 토큰 정보를 갖고 있기 때문에 서버를 확장하는데 부담이 적고, 클라이언트 세션 관리에 대한 서버의 메모리 부담을 줄일 수 있다는 장점이 있습니다.&lt;/p&gt;
&lt;p&gt;하지만 인증 정보가 담긴 토큰이 탈취될 수도 있기 때문에 보안에 취약하며 토큰에 부가적인 정보가 담겨 있기에 서버-클라이언트 간 주고 받는 데이터가 세션 기반의 인증보다 많다는 단점이 있습니다.&lt;/p&gt;
&lt;h4&gt;그럼 JWT란?&lt;/h4&gt;
&lt;p&gt;JWT(Json Web Token)는 말그대로 웹에서 사용되는 JSON 형식의 토큰에 대한 표준 규격입니다.&lt;/p&gt;
&lt;p&gt;하나의 JWT 토큰은 헤더(header)와 페이로드(payload), 서명(signature) 이렇게 세 부분으로 이루어지며 각 구역이 . 기호로 구분됩니다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;&amp;lt;헤더&gt;.&amp;lt;페이로드&gt;.&amp;lt;서명&gt;&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;헤더에는 토큰의 유형과 서명 알고리즘에 명시되고, 페이로드에는 소위 claim이라고도 불리는 사용자의 인증/인가 정보가, 서명에는 헤더와 페이로드가 비밀키로 서명되어 저장됩니다.&lt;/p&gt;
&lt;p&gt;JWT 토큰은 네트워크로 전송되야 하기 때문에 공간을 적게 차지하는 것이 유리합니다. 그래서 JSON 형식으로 데이터를 저장할 때 키를 3글자로 줄이는 독특한 관행이 있습니다.&lt;/p&gt;
&lt;h2&gt;토큰의 저장 위치&lt;/h2&gt;
&lt;p&gt;토큰을 기반으로 구성한 로그인 방식에서 많은 고민이 필요한 부분 중 하나는 토큰을 안전하게 저장하는 위치인 것 같습니다.&lt;/p&gt;
&lt;p&gt;처음에는 이 부분이 막막해서 구글링을 열심히 해봤는데 결국 제가 내린 결론은 &quot;정답은 없다&quot; 였습니다. 검색 결과로 나온 방법들마다 구현 방식이 조금씩 달랐고, 100% 안전한 방식은 없는 것 같았습니다.&lt;/p&gt;
&lt;p&gt;그래도 일반적으로 언급되고 있는 몇 가지 중요한 내용이 있어서 그 부분에 대해서 살펴봤습니다.&lt;/p&gt;
&lt;p&gt;토큰의 저장 위치를 고민해야하는 이유는 바로 보안 때문입니다. 웹 어플리케이션 보안 취약점 중 유저 인증에서 보편적으로 이용되는 취약점은 XSS와 CSRF 공격 두 가지가 있습니다.&lt;/p&gt;
&lt;h3&gt;XSS(Cross-Site Scripting) 공격&lt;/h3&gt;
&lt;p&gt;웹사이트에서 의도치 않은 스크립트를 넣어서 실행시키는 기법을 말합니다. 보통 게시판에 악성 스크립트가 담긴 글을 올리는 형태로 이루어지며, 스크립트가 포함된 글을 열어보게 되면 브라우저에서 원치 않는 스크립트가 실행되는 방식입니다.&lt;/p&gt;
&lt;p&gt;이것을 통해 사용자의 쿠키 정보를 탈취하거나, 사용자 비밀번호를 변경하는 API를 호출하는 행위를 할 수 있습니다.&lt;/p&gt;
&lt;h3&gt;CSRF(Cross-Site Request Forgery) 공격&lt;/h3&gt;
&lt;p&gt;공격자가 다른 사이트에서 API를 요청해 실행하는 공격입니다.
API를 요청할 수 있는 클라이언트 도메인이 누구인지 서버에서 통제하고 있지 않다면 CSRF가 가능한데, 이때 공격자가 클라이언트에 저장된 사용자 인증정보를 서버에 보낼 수 있다면, 제대로 로그인한 것처럼 사용자의 정보를 변경하거나 사용자만 가능한 액션들을 수행할 수 있습니다.&lt;/p&gt;
&lt;p&gt;예를 들어 CSRF에 취약한 은행 사이트가 있다면 로그인한 척 계좌 비밀번호를 바꾸거나 송금을 보낼 수 있는 것입니다.&lt;/p&gt;
&lt;h3&gt;브라우저 저장소 종류 별 보안 이슈&lt;/h3&gt;
&lt;p&gt;클라이언트에서 위 프로세스들을 따라 Access Token 같은 인증정보를 저장할 때 이용하는 저장소는 보통 localStorage나 쿠키입니다.&lt;/p&gt;
&lt;p&gt;둘 다 브라우저에 저장하는 방식으로 페이지를 새로고침 하거나 창을 닫고 다시 접속할 때도 로그인 정보가 이어지도록하기 위해서입니다. 하지만 두 방식은 XSS와 CSRF 공격에 취약할 수 있습니다.&lt;/p&gt;
&lt;h4&gt;localStorage 저장 방식&lt;/h4&gt;
&lt;p&gt;브라우저 저장소에 저장하는 방식으로 자바스크립트 내 글로벌 변수로 읽기 및 쓰기 접근이 가능합니다.&lt;/p&gt;
&lt;p&gt;😈 자바스크립트로 접근이 가능하기 때문에 Refresh Token 또는 Access Token을 저장해두면 XSS 취약점을 통해 그 안에 담긴 값을 이용해 API 요청을 위조할 수 있습니다.&lt;/p&gt;
&lt;h4&gt;쿠키 저장 방식&lt;/h4&gt;
&lt;p&gt;브라우저에 쿠키로 저장되고 클라이언트가 HTTP 요청을 보낼 때마다 자동으로 쿠키가 서버에 전송됩니다. 자바스크립트 내 글로벌 변수로 읽기 및 쓰기 접근이 가능합니다.&lt;/p&gt;
&lt;p&gt;😈 localStorage 저장 방식과 마찬가지로 Refresh Token, Access Token을 쿠키에 저장해두면 XSS 취약점이 있을 때 담긴 값들을 불러오거나, API 콜을 보내면 쿠키에 담긴 값들이 함께 전송되어 로그인한 척 공격을 수행할 수 있게 됩니다.&lt;/p&gt;
&lt;p&gt;😈 쿠키에 Access Token을 저장해 인증에 이용하는 구조에 CSRF 취약점이 있다면 인증 정보가 쿠키에 담겨 서버로 보내지며 공격자는 유저 권한으로 정보를 가져올 수 있습니다.&lt;/p&gt;
&lt;p&gt;😇 쿠키에 Refresh Token만 저장하고 새로운 Access Token을 받아와 인증에 이용하는 구조에서는 CSRF 취약점 공격을 방어할 수 있습니다.
CSRF는 정상 사용자가 img 태그를 보거나 link를 클릭하도록 유도하여 사용자 대신 request를 보내는 방법입니다. Refresh Token은 쿠키로 저장되어 있기 때문에 CSRF를 통해 Access Token을 사용자 대신 요청할 순 있지만 response는 사용자가 받기 때문에 공격자는 이 Access Token을 얻지 못하기 때문입니다.&lt;/p&gt;
&lt;h4&gt;secure httpOnly 쿠키 저장 방식&lt;/h4&gt;
&lt;p&gt;브라우저에 쿠키로 저장되는 건 같지만, 자바스크립트 내에서 접근이 불가능합니다. secure을 적용하면 https 접속에서만 동작하게 됩니다.&lt;/p&gt;
&lt;p&gt;😇 httpOnly 쿠키 방식으로 저장된 정보는 자바스크립트 내에서 접근이 불가능하므로 XSS 취약점 공격으로 담긴 값을 불러올 수 없습니다.&lt;/p&gt;
&lt;p&gt;😇 httpOnly 쿠키 역시 Refresh Token만 저장하고 Access Token을 받아와 인증에 이용하는 구조로 CSRF 공격 방어가 가능합니다.&lt;/p&gt;
&lt;p&gt;😈 쿠키 저장 방식과 같은 이유로 Access Token은 저장하면 안됩니다.&lt;/p&gt;
&lt;p&gt;😈 httpOnly 쿠키에 담긴 값에 접근할 수는 없지만 XSS 취약점을 노려 API 콜을 요청하면 httpOnly 쿠키에 담긴 값들도 함께 보내져 유저인 척 정보를 빼오거나 액션을 수행할 수 있습니다.&lt;/p&gt;
&lt;h4&gt;결론&lt;/h4&gt;
&lt;p&gt;어떤 저장 방식을 택해도 XSS 취약점이 있다면 보안 이슈가 존재하게 됩니다. 그러므로 유저 정보 저장 방식을 바꾸는 것만으로는 방어할 수 없고, 클라이언트와 서버에서 추가적으로 XSS 방어 처리를 하는 것이 필수입니다.&lt;/p&gt;
&lt;p&gt;그래도 최선의 방법을 찾아보자면 Refresh Token만을 secure httpOnly 쿠키에 저장해 CSRF 공격을 방어하고 Access Token은 웹 어플리케이션 내 로컬 변수에 저장하여 API를 요청할 때 Authorization 헤더에 넣어 보내주는 것이 좋겠습니다. 하지만 XSS 취약점을 이용한 API 요청 공격은 무방비하니 XSS 자체를 막기 위해 클라이언트와 서버에서 추가적으로 방어할 필요가 있습니다.&lt;/p&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;br/&gt;
&lt;hr&gt;
&lt;p&gt;&lt;strong&gt;Reference&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://hoime.tistory.com/93&quot;&gt;https://hoime.tistory.com/93&lt;/a&gt; &lt;br/&gt;
&lt;a href=&quot;https://hudi.blog/session-based-auth-vs-token-based-auth/&quot;&gt;https://hudi.blog/session-based-auth-vs-token-based-auth/&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://millo-l.github.io/JWT-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D%EB%B0%A9%EC%8B%9D/&quot;&gt;https://millo-l.github.io/JWT-기반-인증방식/&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://velog.io/@yaytomato/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%90%EC%84%9C-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0#-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%A0%80%EC%9E%A5%EC%86%8C-%EC%A2%85%EB%A5%98%EC%99%80-%EB%B3%B4%EC%95%88-%EC%9D%B4%EC%8A%88&quot;&gt;https://velog.io/@yaytomato/프론트에서-안전하게-로그인-처리하기#-브라우저-저장소-종류와-보안-이슈&lt;/a&gt;&lt;br/&gt;
&lt;a href=&quot;https://ssocoit.tistory.com/235&quot;&gt;https://ssocoit.tistory.com/235&lt;/a&gt;&lt;/p&gt;</content:encoded></item><item><title><![CDATA[첫 사이드 프로젝트 진행기]]></title><description><![CDATA[…]]></description><link>https://klloo.github.io/alteration-detective/</link><guid isPermaLink="false">https://klloo.github.io/alteration-detective/</guid><pubDate>Mon, 31 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h3&gt;구구절절 프로젝트 개요 및 기간&lt;/h3&gt;
&lt;p&gt;수선탐정 프로젝트는 근처의 수선집을 찾아주는 웹 프로젝트 입니다. 별건 아니고 그냥 지도앱인데, 이런 저런 기능은 덜어내고 수선집 조회에만 특화된 지도 앱이라고 보시면 될 것 같습니다.&lt;/p&gt;
&lt;p&gt;프로젝트를 시작한 건 웹 퍼블리셔로 일하던 친구가 학습 목적으로 이런 프로젝트를 진행하려고 하는데 혹시 같이 하지 않겠냐고 제안해줘서 시작하게 되었습니다. 그렇게 해서 기획자 2 퍼블리셔 2 개발자 1 (나) 이렇게 총 5명이 진행을 하게 되었습니다.&lt;/p&gt;
&lt;p&gt;그런데 프로젝트 초기에 친구가 개인 사정으로 나가게 되고, 저와 다른 분들 간의 연결 고리 역할을 해주던 친구가 없어지니 프로젝트는 자연스레 흐지부지 되었습니다. 이 때가 아무 기능 구현 없이 일단 대충 화면 틀만 잡아놓은 상태였습니다.&lt;/p&gt;
&lt;p&gt;하지만 저는 공부를 해야했던 입장이었기 때문에 논의가 필요했던 모호한 기능들은 다 덜어버리고 최소한의 기능만으로라도 구현해보면 좋을 것 같아 진행해보게 되었습니다.&lt;/p&gt;
&lt;p&gt;친구가 나간 이후 슬퍼하며 방황하고….하지는 않았지만 흐지부지 된 이후 다시 맘 먹고 진행하기까지의 공백이 꽤 길었는데 이 기간을 제외하고 순수하게 개발을 진행한 기간은 대략 2주 정도 되는 것 같습니다.&lt;/p&gt;
&lt;h3&gt;기술 스택&lt;/h3&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/fa26a7e2739ca48d335d3373c30b7f77/23296/skills.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 72.46376811594205%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAACR0lEQVR42q1Tu24TURD1t9GBREGDREPB51BGCCFR8SjdgkRrGmKTEIJiR5aJiV/7sL3v5/XuHubM2hCUlFzp6s7Mzpx5nNlOXdfwfR8my5DLtWwbk8kESRyjqSqYskQsMn3SNEVRFKpPp9NWThL4UaQ2ng4DtoGPL/MrOFGoRtt1cfTyFZ4fvcDrt++xWq0QhiFOTk4UqJQYYwz8IEC42QCej0Dk3W7XAoaS4cN8hKltocgLDC9HuP/wEe49eYwHz55icT3XSnq9HgaDAWazGTYC9PX0FP3eZzSzJSLBUEBmo8JT7BrEBkjKWqqOtaqyNFiv19ry4VwMR7AdV+WmafSl7y3AsGjwS+IsGUdi1F3tBPQ8T+W6rtDtdtE/Pt7r9b+AnAX751uWBerKoKl3QkaBPM918NvtVitkAG0kJxMC25hSLwFZbYfoDOBcbGH4YjjE2fdzLBZLOI6D5XKpwUx6rT4WxuMxvsn8pldXsCwL8/lcfZRlotP5MA/qrIKt0YlV3WzZ1I12kstsq/1MGcfvbP/PDCsJzNI2i+8F+NT/iHfdN7gcXupOWu4GliT2nSmMjLbxbUSjPhaWgySJ72Y5NwnKStlAVmbwk5bZrayIK2NZ+AGaaNlWFbpIf55JojVSWak7AR2zFoZDpKKTjMPhzh1a9rwMP84tRLIGcVax39trQwbZvzGVGCtljx95aXflzyFxbbURRsOV6LHK9KnkFyUG3w4HygqZIQyD/fv3kjCSk0hblOM4EtISffn/3vRRlvGfz29+kSkxXCNDWwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;skills&quot;
        title=&quot;&quot;
        src=&quot;/static/fa26a7e2739ca48d335d3373c30b7f77/dd45a/skills.png&quot;
        srcset=&quot;/static/fa26a7e2739ca48d335d3373c30b7f77/948cf/skills.png 138w,
/static/fa26a7e2739ca48d335d3373c30b7f77/6b2ea/skills.png 275w,
/static/fa26a7e2739ca48d335d3373c30b7f77/dd45a/skills.png 550w,
/static/fa26a7e2739ca48d335d3373c30b7f77/23296/skills.png 675w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;백엔드 프레임워크로는 Express를 사용하였습니다. Express는 라우팅과 미들웨어 기반인 경량형 Node.js 웹 애플리케이션 프레임워크입니다. 간단한 프로젝트를 진행할 것이었으므로 가볍게 웹 서버를 구현할 수 있는 점을 고려했고, 프론트와 백 모두 같은 언어로 개발하면 생산성 측면에서도 큰 장점이 될 것 같아 Express를 선택하게 되었습니다.&lt;/p&gt;
&lt;p&gt;데이터베이스는 mysql을 사용했습니다. 저에게는 raw쿼리가 더 익숙했고 orm으로는 복잡한 쿼리를 작성하는데 어려웠던 기억이 있어서 orm은 사용하지 않고 raw쿼리와 knex.js라는 쿼리빌더 라이브러리를 사용했습니다. 그렇기 때문에 프로젝트 인원들이 로컬에서 각각 데이터베이스를 관리하는데 어려움이 있을 것 같아 heroku에 데이터베이스를 생성하고 하나의 데이터베이스를 사용할 수 있도록 했습니다. heroku는 PaaS(Platform-as-a-service) 클라우드 서비스로 heroku를 사용하면 간단하게 프로젝트를 배포할 수 있습니다.&lt;/p&gt;
&lt;p&gt;프론트엔드 프레임워크로는 vue를 사용했고 상태관리 라이브러리로는 vuex를 사용했습니다. vue 와 자바스크립트 학습이 프로젝트의 목표 중 하나였으므로 vue를 사용하게 되었습니다. ui 라이브러리로는 element ui를 사용했습니다. element ui는 깔끔하고 다양한 컴포넌트를 제공해주고 있지만 생태계가 풍부하지는 못하다는 단점이 있습니다. 하지만 공식 문서가 잘 되어있어서 크게 상관은 없었던 것 같습니다.&lt;/p&gt;
&lt;p&gt;소스는 깃허브로 관리했고 notion과 swit이라는 협업툴을 사용했습니다. 주로 개발자간에는 노션을 사용하여 일정과 개발 관련된 진행 사항을 공유했고 기획자와 개발자간에는 swit으로 의사소통을 하였습니다. swit은 얼마 사용하지 못하였지만 노션은 혼자서라도 사용하며 일정을 관리했습니다.&lt;/p&gt;
&lt;h3&gt;개발 내용&lt;/h3&gt;
&lt;p&gt;개발한 기능은 회원 가입 및 로그인, 수선집 조회(지도 및 리스트), 수선집 리뷰 작성, 수선집 즐겨찾기 이렇게가 끝입니다.&lt;/p&gt;
&lt;p&gt;지도와 주소 변환 관련해서는 네이버 api를 사용하였습니다. 주소 검색시에는 공공 api를 사용하였고, 세탁소 데이터 또한 공공데이터에서 가져온 데이터를 가공하여 사용했습니다. 회원가입시 이메일 인증 과정은 nodemailer라는 패키지를 사용하였습니다. nodemailer는 쉽게 이메일을 보낼 수 있도록 하는 Node.js 애플리케이션용 모듈입니다.&lt;/p&gt;
&lt;h4&gt;에러 처리 방식&lt;/h4&gt;
&lt;p&gt;Express는 라우팅과 미들웨어 기반의 프레임워크 입니다. 여기서 미들웨어란 HTTP 요청에 대한 응답 과정 중간에 어떤한 동작을 해주는 함수인데 이 미들웨어의 종류 중 Error Handling 미들웨어를 사용하여 에러를 처리했습니다.&lt;/p&gt;
&lt;p&gt;Error Handling 미들웨어는 express-generator로 생성 시 기본적으로 다음과 같이 만들어져 있는데요. 에러가 발생하면 해당 코드가 동작하게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// error handler
app.use(function (err, req, res, next) {
 // set locals, only providing error in development
 res.locals.message = err.message;
 res.locals.error = req.app.get(&amp;#39;env&amp;#39;) === &amp;#39;development&amp;#39; ? err : {};

 // render the error page
 res.status(err.status || 500);
 res.render(&amp;#39;error&amp;#39;);
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h5&gt;비동기 에러 처리&lt;/h5&gt;
&lt;p&gt;Express는 ES6가 나오기 이전에 거의 다 만들어졌기 때문에 Error Handling 미들웨어가 비동기 에러를 처리하는데 잘 작동하지 않는다고 합니다.
그래서 매 비동기 요청마다 try, catch를 달아주어야 하는데 이를 해결하기 위해 router 함수를 감쌀 수 있는 wrapper 함수를 정의하여 사용했습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;module.exports = wrapAsyncController = (fn) =&amp;gt; {
 return (req, res, next) =&amp;gt; {
  // 모든 오류를 catch()로 처리하고 next()로 전달한다.
  fn(req, res, next).catch(next);
 };
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이 wrapper함수를 다음과 같이 router에 감싸서 사용하면 매번 try, catch를 사용하지 않고도 비동기 에러 처리가 가능하게 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const wrapAsyncController = require(&amp;#39;../controllers/wrapAsync.controller&amp;#39;);

router.post(&amp;#39;/register&amp;#39;, wrapAsyncController(UserController.registerUser));&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;h5&gt;응답 클래스 정의&lt;/h5&gt;
&lt;p&gt;서버와 클라이언트 통신 시에 일관된 형식으로 응답을 주고받을 수 있도록 응답 클래스를 정의하여 사용했습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;class Result {
 success; // 성공 여부
 data; // 전달 데이터
 message; // 오류 메시지

 constructor() {
  this.success = false;
 }
}

module.exports = Result;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;화면단에서는 아래와 같이 사용할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;cpp&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;login(loginInfo)
   .then((data) =&amp;gt; {
     const result = data.data;
     // 응답에 성공한 경우
     if (result.success) {
		// data로 전달받은 사용자 정보를 가져온다.
       const userInfo = result.data;
				...
     } else {
		// 에러가 발생한 경우 전달받은 에러메시지를 출력한다.
       this.$toast.error(result.message);
     }
   })
   .catch((err) =&amp;gt; {
     throw new Error(err);
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
 &lt;br/&gt;
&lt;h4&gt;회원 가입 및 로그인&lt;/h4&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/431a633a2240b5a21cfafb82ec16cdea/4e814/loginjoin.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 59.42028985507246%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAAB0klEQVR42pVTy27bMBDM//9Bjz30UAQFWjQ5BCgatAejQQ8pDMFJakvK0w/Flk1ZEilyycmSsmIFKRCUwIgUxR3O7o4OtHYoBKNkVA6idthIB2UcrLUwhuCce4F234S5v+/HwZbJ4rFFfG0xuWPMLEYLwrK2IKNR1xL94QMNEe/XgbC/7xEIr1OLi7HB2blCMre4ygi59ISOAx208YcR4B9kOQMFNI1fv7wsEKaxV0j4/UdhODH4u7RYsUJrLBMSfFl6YSBm2QiNShKnbsM77dQ+pzxOCRGrjBKD0Zywlr6mBum0xjxrkC00slmDhpWzXqhGQ6qG1RsGhVoHwrJwWD2acKOoLLbKIStZGacZpRIfTnKc/BA4/S7w81ggn+sQqJQOpJbTdx06wpt7hdupxHTBSph8+qixru0uQbxqSttR/512c68p3jLvj3K8O1zi4+cNPh2ucfxFYFW2B31puobsnAHZWAzjCqNJjTiRSK4kljO9r+EoKhFdFhjf6GCb4Z1G/g+F3VpUhK8DgW+DAoNfWwxOC6QXck/ou5zecqfvCcmitc3qzZRfj9Y2xZ4weSDE7MNL78M3CH0z+nhuSmdeqVrUbNaq8X9DWzT3H/ApPwFgjKAMgWCgOAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;loginjoin&quot;
        title=&quot;&quot;
        src=&quot;/static/431a633a2240b5a21cfafb82ec16cdea/dd45a/loginjoin.png&quot;
        srcset=&quot;/static/431a633a2240b5a21cfafb82ec16cdea/948cf/loginjoin.png 138w,
/static/431a633a2240b5a21cfafb82ec16cdea/6b2ea/loginjoin.png 275w,
/static/431a633a2240b5a21cfafb82ec16cdea/dd45a/loginjoin.png 550w,
/static/431a633a2240b5a21cfafb82ec16cdea/d4c13/loginjoin.png 825w,
/static/431a633a2240b5a21cfafb82ec16cdea/99f37/loginjoin.png 1100w,
/static/431a633a2240b5a21cfafb82ec16cdea/4e814/loginjoin.png 1335w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;지도 조회 및 검색&lt;/h4&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/107342379a5425ffa6401919ff886129/bb051/home.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 64.4927536231884%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAAAsTAAALEwEAmpwYAAACOklEQVR42o2TW2sTQRTH8/l88Qv41ooKUkpJrLQ1aK0IbWMK+QiC4FsLoW0a/Rg+SERTm+7uZGdv2cvsbnby95zNVUXpgWF3Z+b89n9uFa012Pg5Ho/L98lkgt/2i2Kxz2v+zmZLiV6vh36/jzzPUVEqh1IZ4iRBGMUEKEpwTothiVIIwnAB4H3pepCOW353u13U63U0T07geS4qYZjBkSFBUzA8jmOkqSJQiihOUBB0rpgVFKSWz9I0K4Ht80tsb1fRaDTguATkA9eL4LoK4YhACV9OSidFZ4WeKivDnKXFJnX8M7b3Zx08ePQEx6934dB+JY4VpNGHMCyIoQ/D8AkaUQrULAW6VMVKi1k+HS8oz9g+nF7g/voWNl/sUz5tVDIKTxDQHAwgbq9hWR4CUsqQiJzSLCPFKTJ6TmZFYnVZlpfAj2dt3Hv4HGs7xxC2QzkcBbCHFlwxQCQMkh3BdyXG+bgEMogXg/VKledd0OmcY21zC+s7h7BsCllRdYdiCMf6CWH6pNCm5N6A/Qq9DLUszqJ1lsBPV108q25go34A0/aoKCqBHEq45jfc3H4huAVTLtvkT1sqnPbmRfsU1aeP8fbNAUUnSSFV1AscqrCE4XyFIR3Yfoh/2d8hX6JWq+Ho6JA6hUJOVATpWfC9EQzrB66N79SgEbveCXhFIe/u7eFdszkFzkcuTmIqQoA8U+Sk7xCynk3KZ7x8tY9Wq0VCKIerF7WeJnyyMrf/W2whjaUQApJmmlvtF048zKWCz1pJAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;home&quot;
        title=&quot;&quot;
        src=&quot;/static/107342379a5425ffa6401919ff886129/dd45a/home.png&quot;
        srcset=&quot;/static/107342379a5425ffa6401919ff886129/948cf/home.png 138w,
/static/107342379a5425ffa6401919ff886129/6b2ea/home.png 275w,
/static/107342379a5425ffa6401919ff886129/dd45a/home.png 550w,
/static/107342379a5425ffa6401919ff886129/d4c13/home.png 825w,
/static/107342379a5425ffa6401919ff886129/99f37/home.png 1100w,
/static/107342379a5425ffa6401919ff886129/bb051/home.png 1212w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;수선집 상세 화면&lt;/h4&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/2d7bdd87686d58e5d5f79aa94e0478cc/27b8e/detail.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 98.55072463768117%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAAAsTAAALEwEAmpwYAAAD3ElEQVR42m1Ua08bRxTdn5kPfYWUqN/Sj+0HmkJIShxKAkqkpoWipEWhUpNGqFVxCgXaJOAnSTGWwW+v3/Z614992uvTe9fexY060vV4d++cOffcMyNYVh/9fh+DAQXNmqZDVTXnnW0PaLbAoyCKODw6QiQcRjgcQiAQwBE9h0IhRCIRBOk5Ho9DUAnAHg6dRfyr6QY6PZXARu9s23bmbb8fMzNfYPHrJdz23cGN+Xlc/3IWXy0swOfzYf7mLayurkLo0eLYmxBe+58isudH8OUrHB4cIBIIIpE4xeuXu7AsE3t7+7j68RSufngJn1x+H9MfXcb0lSuYnprCp9eu4YP3LmFlZRlCtVLGz2t3sXF/Dk8fPcDm2kNsPv4eT9a/xdaTVTx+cBNKS8IBbbK4MIe7t2awvDCLlcUFLC/5sLx4G999cx9Lvht4tL4GoZhN48d7s3jx7Adsb/2EF883seP/Hdc/+xwb9+aw8fAOKtUqaRdCrVYDa26aJibHcCxZIHAEQZJk7P/hx+HuDo7/+hvZ5DlyuRwS52m8CR5g+7df0Gi1cRyNIpPJolyuwNB1WKZFwBY1c0CA9hgwSE1Re0ink5CVutOW8Wbe0K0hjAEQjUZQKpWhKB2w7hzdrkouGHgMw+EIhG6vg26ngb7ZQblSRZMYS7KCnqpCJyamYTjJbI92u+2VyN3nGE4wYPsIOtlEkjuwaKcu7aq0OzAM01vg2oYBJUmibzqkZg3lUh6FfAaimEOzWXc8GyVZBDaypqmODjbpwR9YFw42N7N0d282G6jXShAJqFzMIZ9L4fzsFPHTt06eByiTLgYJ7JrZHcxOpdJHDMOkn+IwFAtplFzARAyy3BprGCZAKrlYqqBZL6BvtDG0R0fNIO00TSPhu16yTIDMOp9NIpNKIHkWxz9vIyRB40JDZsVlwjYwsDRqguosci3B/93kNgGyEwydG6Y5bFkuy7IuALlLzIaT67UKlZNBLntO5VBZZZE6q4yTo5ClKmC1MDBkr1mTxvYAuWsMxJ1jsQv5NHkzgVjsGGd0nt1kqdWCqhnQHSsNHSA3PA35gY9ShdgUxawDyqKnkwlimiKPdrxkRVH+w4gnjpFsw5GxXeqKLJHYdOxI8DQJzlZIp848DUeAF8bGcBKYZxthLpmFN0lUmW6UYiHrBOvHYNlMyrm6eLDHGo0GHbke+VGiBup4Feti/XkTv261ENrv0QVCgMyAffjuDfKu4HxSWqQh53cJFBjgOKXj2U4bf+52cRoynRxhkvb/hSvJyckJXbgJum3KdNxEFAoF1CoipHoR9bqIGgUD/gtWIrD+3KUreAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;detail&quot;
        title=&quot;&quot;
        src=&quot;/static/2d7bdd87686d58e5d5f79aa94e0478cc/dd45a/detail.png&quot;
        srcset=&quot;/static/2d7bdd87686d58e5d5f79aa94e0478cc/948cf/detail.png 138w,
/static/2d7bdd87686d58e5d5f79aa94e0478cc/6b2ea/detail.png 275w,
/static/2d7bdd87686d58e5d5f79aa94e0478cc/dd45a/detail.png 550w,
/static/2d7bdd87686d58e5d5f79aa94e0478cc/d4c13/detail.png 825w,
/static/2d7bdd87686d58e5d5f79aa94e0478cc/27b8e/detail.png 836w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h3&gt;회고&lt;/h3&gt;
&lt;p&gt;데이터베이스 설계와 백엔드부터 프론트엔드 전부 혼자 개발해본 경험이 처음이라 큰 의미가 있었습니다. 하지만 미비한 기획에서 시작한 탓인지 완성도가 조금 낮은 상태로 프로젝트를 종료하게 되었습니다.&lt;/p&gt;
&lt;p&gt;어차피 퍼블리셔를 제외한 개발자는 저 혼자였으니 인원이 빠져나가도 크게 상관은 없었지만 모든 기능과 기획에 대해 혼자 의사결정을 해야하는 부분이 생각외로 고민도 많았고 힘들었습니다. 그래서 처음 기획했었던 기능 대다수를 걷어낸 부분이 제일 아쉬운 것 같습니다.&lt;/p&gt;
&lt;p&gt;스타일 관련된 부분을 통일성 있게 관리하지 못했다는 점도 아쉬웠습니다. 프로젝트 초기에는 퍼블리셔분들이 잘 해주셨는데 혼자가 된 이후 어떻게 관리할지 갈피를 못잡고 전역으로 선언한 스타일도 많아서 !important 를 남발하는 등 그야말로 주먹구구식으로 진행해버리고 말았습니다. 아직도 스타일 관리와 적용에 대해서 모르는 부분이 많지만 그 중요성 만큼은 확실히 알게 되었습니다.&lt;/p&gt;
&lt;p&gt;node로 백엔드 개발을 진행한 부분은 굉장히 유익했던 것 같습니다. 이전에 백엔드 개발로는 스프링을 사용했었기 때문에 자연스럽게 MVC 구조를 따라 설계를 했습니다. Express는 자유도가 높은 것이 장점이자 단점인데 이를 충분히 활용하지 못한 것 같아 Nest.js를 사용하는게 낫지 않았을까 하는 생각도 들었지만 많은 것을 배울 수 있어서 큰 아쉬움은 없는 것 같습니다.&lt;/p&gt;
&lt;p&gt;프로젝트의 주된 목적이었던 vue 프레임워크 활용에 대해서도 어느정도 달성한 것 같습니다. 이전에도 vue로 개발은 종종 해봤지만 프로젝트를 처음부터 진행해본 것은 처음이었고, 주로 지도와 주소에 관련된 API를 다룬 것도 큰 도움이 되었습니다.&lt;/p&gt;
&lt;p&gt;여러모로 아쉬운 부분이 더 큰 프로젝트였지만 많은 것을 배울 수 있었던 것 같습니다. 사실 결과물 자체는 완성도가 조금 낮다고 생각되어 어디 내놓을만한 프로젝트는 아니지만... 진행하며 깨달은 점이 많아 기록해두고 싶었습니다. 원래 과정보다는 결과가 중요하다는 주의였는데, 이 프로젝트를 계기로 생각이 많이 바뀌게 되었습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA["window" is not available 에러 해결]]></title><description><![CDATA[다크모드를 적용하고, 로컬에서 잘 돌아가는 것을 확인한 다음 배포를 하려고 했는데 이런 에러가 발생했습니다.  에러 메시지를 읽어보니 window…]]></description><link>https://klloo.github.io/gatsby-window-not-abailable/</link><guid isPermaLink="false">https://klloo.github.io/gatsby-window-not-abailable/</guid><pubDate>Sat, 29 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;다크모드를 적용하고, 로컬에서 잘 돌아가는 것을 확인한 다음 배포를 하려고 했는데 이런 에러가 발생했습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/3b6e410ab151fb2ba7e0f4354d77fbb9/076ca/windowisnot.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 25.362318840579707%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA4UlEQVR42m2Q6W6DMBCEeYlwGDDBF75IIJVb9f0fbLLrKJVa9cd4fex+mnHjtw0xBGyOaoykgETVe49A9zlnpJRq3fe9Vu5zzsEYg43muZe1risaXpTW0MYS1GFVCstKWpYqfjdGV1lrK0hKibZt0XXdj/jc9z0BeVBpfJSC76+CdM8w4QX3wUOIAZfL72EeFEJgGIYq3r/PjSIHV3ZJDg1BOHL0luJ6ihehtSJHM+Z5xjRNGMex6g37q2ZZJEZ5haCYJu8o5ROPx4nbLeM8DxzHncCe/soSXNc/4/js8j/gEwM6i4PxhqM+AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;windowisnot&quot;
        title=&quot;&quot;
        src=&quot;/static/3b6e410ab151fb2ba7e0f4354d77fbb9/dd45a/windowisnot.png&quot;
        srcset=&quot;/static/3b6e410ab151fb2ba7e0f4354d77fbb9/948cf/windowisnot.png 138w,
/static/3b6e410ab151fb2ba7e0f4354d77fbb9/6b2ea/windowisnot.png 275w,
/static/3b6e410ab151fb2ba7e0f4354d77fbb9/dd45a/windowisnot.png 550w,
/static/3b6e410ab151fb2ba7e0f4354d77fbb9/d4c13/windowisnot.png 825w,
/static/3b6e410ab151fb2ba7e0f4354d77fbb9/076ca/windowisnot.png 914w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;에러 메시지를 읽어보니 window객체가 없다는 말이었습니다.&lt;/p&gt;
&lt;h3&gt;원인&lt;/h3&gt;
&lt;p&gt;자바스크립트에는 전역 객체가 존재합니다. 전역 객체란 모든 객체의 유일한 최상위 객체를 의미하며 일반적으로 Brower-side에서는 window , Server-side(Node.js)에서는 global 객체를 의미합니다.
Node.js에서는 window라는 객체가 존재하지 않아, 빌드시 초기 Gatsby가 서버사이드 렌더링 할 때 window객체를 참조할 수 없어 생기는 문제였습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/1a8f2d899531b6802d2aca381f90b4da/d2a60/error.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 37.68115942028986%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAAAsTAAALEwEAmpwYAAABeElEQVR42pVR226rMBDM/39YLj1SouYhOm2VEDAXG9tgA0kKhM4ZO1LfD9Job97Z2WW12+1wOByw3W5xOp2wXq/x9vYHx+MRm80G+/0e//OtPr8+SbjH+/Edl8sFaZoiSZLof3z8xfl8xjzPeD6fEcuyRIRczEc7YZ5GLKyvOtejdzfYukXTtHCtgzUWjWVsG7SMa6UhK/ULrS2869D5Hr4x6BsNZxTuvSdhO2Bo7xj8/UVA0kASLeG9Jzr0XUcSxs6TyGGapl/V0/RSG1fW2kAbQutIqKSKioLaWtUoiwqWeaskVCHQWkObQcsqqq1rjaqsCBnJVyLLkecFrskVwU9TQT+FEDmyTCC9ZtG/sB5iIQokzIWeUMv4viBhylo/DFRYcyKVaE4q8vI1lQpDg5J1VKCLEuoqYFi39BtpYKSD4S1t2JBvTVnyhj1v2NxQszGsLKWKNqwaVjf8OWGgYd1WJM9lxPQYMX8vGL9HjOOI6faI+FkW/AMjc1lJvXqm2QAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;error&quot;
        title=&quot;&quot;
        src=&quot;/static/1a8f2d899531b6802d2aca381f90b4da/dd45a/error.png&quot;
        srcset=&quot;/static/1a8f2d899531b6802d2aca381f90b4da/948cf/error.png 138w,
/static/1a8f2d899531b6802d2aca381f90b4da/6b2ea/error.png 275w,
/static/1a8f2d899531b6802d2aca381f90b4da/dd45a/error.png 550w,
/static/1a8f2d899531b6802d2aca381f90b4da/d2a60/error.png 807w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://www.gatsbyjs.com/docs/debugging-html-builds/&quot;&gt;공식문서&lt;/a&gt;를 읽어보니 웹페이지를 일단 빌드하기만 하면 이후 브라우저 환경에서는 window 객체를 참조할 수 있으니 일단은 빌드될 수 있도록만 해주면 될 것 같았습니다.&lt;/p&gt;
&lt;h3&gt;해결&lt;/h3&gt;
&lt;h4&gt;1. window가 정의되어 있는지 확인&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const isBrowser = typeof window !== &amp;quot;undefined&amp;quot;
if (isBrowser) {
    window.localStorage.getItem(&amp;quot;isLoggedIn&amp;quot;) === &amp;quot;true&amp;quot;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이런식으로 현재 window 객체가 존재하는지 확인한 후, 존재하는 경우에만 window 객체를 참조할 수 있도록 해주면 됩니다.&lt;/p&gt;
&lt;h4&gt;2. useEffect 사용하기&lt;/h4&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;useEffect(() =&amp;gt; {
    window.localStorage.getItem(&amp;quot;isLoggedIn&amp;quot;) === &amp;quot;true&amp;quot;
  }
);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;useEffect&lt;/code&gt;는 DOM형성 후에 실행이 되는 hook입니다. 즉 브라우저에서만 코드가 실행됩니다. 이렇게 하면 초기 빌드 시 &lt;code class=&quot;language-text&quot;&gt;useEffect&lt;/code&gt; 내부 코드는 실행되지 않으므로 &lt;code class=&quot;language-text&quot;&gt;useEffect&lt;/code&gt; 내부로 에러가 발생하는 코드를 옮겨주면 해결됩니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Gatsby 블로그에 다크모드 적용하기]]></title><description><![CDATA[…]]></description><link>https://klloo.github.io/darkmode/</link><guid isPermaLink="false">https://klloo.github.io/darkmode/</guid><pubDate>Thu, 27 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;h2&gt;다크모드&lt;/h2&gt;
&lt;p&gt;다크모드를 적용해봤습니다. 원래 향후 계획에도 없던 ... 기능인데 너무 하얘가지고 가만히 보고 있자니 가끔 눈이 아파서 이참에 구현을 해봤습니다.
다크모드를 한 번도 구현해본적은 없지만 막연하게 그냥 전역으로 변수 두고 스타일 변수만 바꿔주면 되겠지 ... 했는데 생각보다 고려사항이 많았습니다. 게다가 서버 사이드 랜더링은 처음이라 더 어려웠던 것 같습니다. 여러 포스팅들을 읽고 읽으면서 제일 이해가 쉬운 방법으로 따라해봤습니다.&lt;/p&gt;
&lt;h2&gt;1. 버튼 만들기&lt;/h2&gt;
&lt;p&gt;먼저 버튼을 만들어 줬습니다. 버튼은 그냥 간단하게 해와 달 아이콘으로 표현을 해봤습니다.
처음에는 폰트어썸을 사용했는데 돈을 내지 않고서는&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/74d479f7782f4c2126f447a04823a968/a65ce/uglyicon.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 62.31884057971014%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAMCAYAAABiDJ37AAAACXBIWXMAAAsTAAALEwEAmpwYAAACOUlEQVR42kVTyW7aUBT1J2ebfkk3XXXXVdqoSqssKlWdU6RCFDCCBAiTwUwe3vzs03ufgTzJ4vo83+Gcc4ke+iO0On38bccYjuYQUmG52kJpjVJIPI5mGD8vccgKHHKFQ+EoLpv3M+bPWDSZJhiO5xg8TTFdrFGUAptdBiEU8lxgRtgiSeljgf1mgu38D/a79bEAYekTtos7HPZb7AmLjLGo65oeoKoqSKlpOgNrHZxzhNVQSkFbQG++YNO5gCuHxMSDUiGXV1i3L1CpOUrCIu+rUOD12w80fhmKeu+JrsL7z99hHSe6gJckx127F2JjGoxzV+kOfDiOHCXwJK1ODG0MnOd3LmIRD8eU1MTchH9ZFuIDZsbDWGeR5cVLQe7Oh5iFw1TtEXO+ATmZmzT39oxxE5bKuuqloFQWVixRLD7ClFPwu1SO4gny2TWsXBJVwoguN9KUxMUEbYDSNHXWg0w+weoDyaQRKQP4MsauewmX/YMyZAJjeQtZ/xW8oARNhtAanaZnqlJKMBG1ukF6f4naJMGoyJJ+dI+brz3SsNGzriskaY6r2w6tgggYn3mywfXtj6Alm8JnOEnx5t23EHPTYAoL2+0PiIIKurAxJe1j+yEOWDOVJ/FLtLsDkoSmNc1KFUWBePAY7tnU6GSA0u4ocEOL14W1PDnOumlaRmahOT6a0qxdk8v6RkKQyGoHn/2EkSnpYMLj5BpV9guW7lhsQWY5ldB3hOki7Ckb6MQzYb9hdEn/MoX/WdGWGs/zeaUAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;uglyicon&quot;
        title=&quot;&quot;
        src=&quot;/static/74d479f7782f4c2126f447a04823a968/dd45a/uglyicon.png&quot;
        srcset=&quot;/static/74d479f7782f4c2126f447a04823a968/948cf/uglyicon.png 138w,
/static/74d479f7782f4c2126f447a04823a968/6b2ea/uglyicon.png 275w,
/static/74d479f7782f4c2126f447a04823a968/dd45a/uglyicon.png 550w,
/static/74d479f7782f4c2126f447a04823a968/a65ce/uglyicon.png 559w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;앞에 두 개 아이콘 밖에 사용할 수가 없었는데 뭔 톱니바퀴 같기도하고 하여간 너무 맘에 안들어서 그냥 이모지로 표현을 해버렸습니다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 277px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/079fd956fc0dd2082d64ef4f453c705e/2a985/emojiicon.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 105.07246376811594%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAVCAYAAABG1c6oAAAACXBIWXMAAAsTAAALEwEAmpwYAAAB80lEQVR42rWV30vbUBTH+yYMBHFTZ3/YaBObaKzWthZ/oFj8UbV2Nuqc1h8g+iKCL74JKoqisD0Lgk8y2F+0B1EUH0TnsD5oBZfka27aKm65aR164HNzOeee7z03OZdY8MpmIYOqqoYoivKIUdxQMJNotvhZDE+bGYla/hbIzM8vfuHw6BjHJ6e4vPydihHufkK9P0vNVSW7YMZubm+RuL7GVSKBZDKZ3uxeEzwAlDuQFGqFLzsysh9ZlmXI2oJ/kNM886fW/tFycnqHuRot720EaX2WC4aN/T9GbWwyLC2vIxyRMDgygdhwHFHpCyIDn3Wi0qjuGxiKo1+aQm90GPMLi+ZXjyTkF9pgLxdQYmdRU9+I9q4Igs0h1Pqa8MHKgRc4LM2xKLE60NTWTa1SFxybnIHV6QZfEwAreOFvbEdbRx9aQz3wBVtRwXsh1nohhUUwbBU6e2LmgqPj0/jo4MBV1cPF14HhPHCyog5T6QGr+SrcdXBwflgZHp3hT+aC8clZ2BhBq7ABldV+uEVCIP306z6C4AmgzCWiu096WYU0SNymVdiRrcLxqRntg/B6BW7RR4XEnWy13hGmgpHYCPLyi1Bsd+F9aTmVIpsL7wpKEWwJmQvuf/+BlbVNbG5/w8bWVyokvrq+hZ3dPfM+fM1/ygNRoXzsbiRwtwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;emojiicon&quot;
        title=&quot;&quot;
        src=&quot;/static/079fd956fc0dd2082d64ef4f453c705e/2a985/emojiicon.png&quot;
        srcset=&quot;/static/079fd956fc0dd2082d64ef4f453c705e/948cf/emojiicon.png 138w,
/static/079fd956fc0dd2082d64ef4f453c705e/6b2ea/emojiicon.png 275w,
/static/079fd956fc0dd2082d64ef4f453c705e/2a985/emojiicon.png 277w&quot;
        sizes=&quot;(max-width: 277px) 100vw, 277px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;사실 이것도 100% 마음에 들지 않아 언젠가 다시 바뀔지도 모를 것 같습니다.&lt;/p&gt;
&lt;h2&gt;2. 다크모드 설정하기&lt;/h2&gt;
&lt;p&gt;이제 사용자 설정 혹은 시스템의 설정에 따라 다크모드를 설정해줍니다. 다크모드 설정 방식은 다음과 같은 방식으로 진행을 했습니다.&lt;/p&gt;
&lt;p&gt;먼저 다크모드로 설정하고 싶다면 body에 &apos;dark&apos;라는 클래스를 추가해줍니다. 그리고 글로벌 스타일에서 기본 스타일과 다크모드 스타일을 각각 정의 해준 뒤, body 클래스에 따라 다른 스타일 선택해줍니다.
이 때 기본 스타일과 다크모드 스타일에서는 css변수를 다르게 사용해줬는데 키값은 동일하게 지정하되 해당 키값에 대한 색상 값을 다르게 주는 방식으로 하여 하위 스타일에서 같은 변수명을 사용하더라도 모드에 따라 다른 색이 적용되도록 했습니다.&lt;/p&gt;
&lt;p&gt;예를 들어 &lt;code class=&quot;language-text&quot;&gt;--background-color&lt;/code&gt; 값을 기본 스타일에서는 white, 다크모드 스타일에서는 black으로 설정하고 해당 변수 값을 body의 배경 색상으로 지정해주면, 모드에 따라 다른 색상이 적용되는 방식입니다.&lt;/p&gt;
&lt;p&gt;이를 위해서 먼저 다크모드일 경우 body에 &apos;dark&apos; 클래스를 추가해주는 작업을 먼저 진행했습니다.&lt;/p&gt;
&lt;h3&gt;시스템 설정에 따라 다크모드 설정&lt;/h3&gt;
&lt;p&gt;요즘 많은 시스템들이 다크모드를 지원해주고 있습니다. 그에 따라 웹에서도 prefers-color-scheme 라는 미디어 속성으로 시스템의 다크 테마 여부를 탐지할 수 있게 되었습니다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;prefers-color-scheme&lt;/code&gt;라는 미디어 속성을 사용하면 다크 테마 여부를 감지할 수 있는데 다음과 같이 사용할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;css&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;@media (prefers-color-scheme: dark) {
 body {
  background: black;
  color: white;
 }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이런 식으로 사용해주면 시스템의 다크모드 설정에 따라 다른 스타일을 제공해줄 수 있습니다.&lt;/p&gt;
&lt;p&gt;물론 시스템의 설정도 중요하지만 사용자가 설정을 변경한다면 사용자의 설정을 따라가야 합니다. 이렇게 사용자의 설정과 시스템의 설정을 모두 고려하기 위해서는 스크립트로 사용을 해야하는데, 미디어쿼리를 스크립트로 처리하기 위해서는 matchMedia 를 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;code class=&quot;language-text&quot;&gt;window.matchMedia&lt;/code&gt;는 주어진 미디어 쿼리 문자열의 분석 결과를 나타냅니다. 이 함수는 &lt;code class=&quot;language-text&quot;&gt;MediaQueryList&lt;/code&gt; 를 반환하는데 이 객체는 media와 matches라는 두 프로퍼티가 존재합니다. media는 사용한 미디어쿼리 문자열을 반환하고, matches는 현재 화면이 미디어 쿼리의 범위에 들어가면 true, 아니면 false를 반환합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const darkQuery = window.matchMedia(&amp;#39;(prefers-color-scheme: dark)&amp;#39;);
console.log(darkQuery.matches ? &amp;#39;dark&amp;#39; : &amp;#39;light&amp;#39;);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 사용할 수 있습니다.&lt;/p&gt;
&lt;p&gt;또 하나 고려해야할 부분은 시스템이나 사용자의 설정을 기억해야 한다는 점입니다.
다시 방문 했을때에도 이전의 설정을 기억하여 그대로 제공하도록 해주는 기능이 필요합니다. 다시 방문했을때는 다시 설정하면 되지 라는 생각을 잠시 했지만 문제는 새로고침입니다. 이렇게만 한다면 새로고침 시 설정이 초기화되어... 굉장히 무능한 블로그 같고 .. 하여튼 불편합니다. 이를 위해서는 localStorage를 사용하여 브라우저에 마지막으로 설정한 모드를 저장해줬습니다.&lt;/p&gt;
&lt;p&gt;이를 종합하여 시스템 설정에 따라서 body 클래스에 &apos;dark&apos;를 추가하거나 제거해주기 위해서는 다음과 같이 할 수 있습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const DARK = &amp;#39;dark&amp;#39;;
const LIGHT = &amp;#39;light&amp;#39;;
// 시스템 설정이 다크모드인지 확인
const darkQuery = window.matchMedia(&amp;#39;(prefers-color-scheme: dark)&amp;#39;);

// localStorage에 저장된 테마 불러오기
const savedTheme = localStorage.getItem(&amp;#39;theme&amp;#39;);
// 다크모드라면 theme를 dark로, 아니라면 light로 설정하고 theme에 따라 클래스 변경
const newTheme = savedTheme || (darkQuery.matches ? DARK : LIGHT);

const setTheme = (DARK) =&amp;gt; {
 if (newTheme === &amp;#39;dark&amp;#39;) {
  document.body.classList.add(&amp;#39;dark&amp;#39;);
 } else {
  document.body.classList.remove(&amp;#39;dark&amp;#39;);
 }
 // 새로 설정된 테마를 localStorage에 저장
 localStorage.setItem(&amp;#39;theme&amp;#39;, newTheme);
};
// 동적으로 시스템 테마 변경에 따라 바뀌도록 하려면 미디어 쿼리 state 변경에 따라 변경될 수 있도록 이벤트 리스너를 넣어줄 수 있다.
darkQuery.addListener((e) =&amp;gt; {
 setTheme(e.matches ? &amp;#39;dark&amp;#39; : &amp;#39;light&amp;#39;);
});&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이제 이 스크립트를 어디서 실행하는지가 문제입니다.&lt;/p&gt;
&lt;p&gt;이게 적용하기 까다로운 이유가 해당 속성이 css 속성이기 때문에 server 에서 받아올 수 없어서 그냥 react의 lifecycle 내에서 현재 테마를 가져오고, 그에 따라 스타일을 조정하면 시스템이 다크 테마여도 잠시 라이트 테마가 보여지는 현상을 겪을 수 있다고 합니다.&lt;/p&gt;
&lt;p&gt;이 문제를 해결하기 위해서는 위 스크립트가 화면이 painting 되기 전에 실행되어야 합니다. 제가 참고한 포스팅에서는 스크립트를 body 바로 다음에 위치시켜서 body 내부 엘리먼트들이 페인팅 되기 전에 실행하도록 하였습니다. 이렇게 두면 스크립트는 DOM 파싱을 막으므로, 위 스크립트가 실행된 후에 페인팅이 되는 것이 보장되기 때문입니다.&lt;/p&gt;
&lt;p&gt;Gatsby에서는 gatsby-ssr의 onRenderBody API를 이용할 수 있습니다. 해당 API는 setPreBodyComponents 함수를 제공하는데, 이 함수를 통해 body 바로 하위에 스크립트를 넣어줄 수 있습니다.
(아니면 html.js를 수정할 수 있는데, Gatsby Theme 내에서는 제공이 안되어 권장하지는 않는다고 합니다.)&lt;/p&gt;
&lt;p&gt;결과적으로 gatsby-ssr.js 파일에 다음과 같이 적용해주면 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const React = require(&amp;#39;react&amp;#39;);

exports.onRenderBody = ({ setPreBodyComponents, setHtmlAttributes }) =&amp;gt; {
 const script = `
    const DARK = &amp;#39;dark&amp;#39;;
    const LIGHT = &amp;#39;light&amp;#39;;
    
    const darkQuery = window.matchMedia(&amp;#39;(prefers-color-scheme: dark)&amp;#39;);
    const savedTheme = localStorage.getItem(&amp;#39;theme&amp;#39;);
    
    const newTheme = savedTheme || (darkQuery.matches ? DARK : LIGHT);

    const setTheme = (DARK) =&amp;gt; {
    if (newTheme === &amp;#39;dark&amp;#39;) {
        document.body.classList.add(&amp;#39;dark&amp;#39;);
    } else {
        document.body.classList.remove(&amp;#39;dark&amp;#39;);
    }
    localStorage.setItem(&amp;#39;theme&amp;#39;, newTheme);
    };
    
    darkQuery.addListener((e) =&amp;gt; {
    setTheme(e.matches ? &amp;#39;dark&amp;#39; : &amp;#39;light&amp;#39;);
    });
  `;
 setHtmlAttributes({ lang: `ko` });
 setPreBodyComponents(&amp;lt;script dangerouslySetInnerHTML={{ __html: script }} /&amp;gt;);
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br/&gt;
&lt;h3&gt;사용자 설정에 따라 다크모드 설정&lt;/h3&gt;
&lt;p&gt;아까 만들어 둔 버튼을 연동하여 사용자 설정에 따라서도 다크모드가 설정될 수 있도록 만들어야 합니다. 먼저 버튼에서 해당 스크립트의 함수 및 값을 사용할 수 있도록 window 객체에 넣어줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const React = require(&amp;#39;react&amp;#39;);

exports.onRenderBody = ({ setPreBodyComponents, setHtmlAttributes }) =&amp;gt; {
 const script = `
  window.__DARK = &amp;#39;dark&amp;#39;;
  window.__LIGHT = &amp;#39;light&amp;#39;;
  
  const darkQuery = window.matchMedia(&amp;#39;(prefers-color-scheme: dark)&amp;#39;);
  const savedTheme = localStorage.getItem(&amp;#39;theme&amp;#39;);

  window.__theme = savedTheme || (darkQuery.matches ? window.__DARK : window.__LIGHT);

  window.__setTheme = (newTheme) =&amp;gt; {
    if (newTheme === window.__DARK) {
      document.body.classList.add(window.__DARK);
    } else {
      document.body.classList.remove(window.__DARK);
    }
    localStorage.setItem(&amp;#39;theme&amp;#39;, newTheme);
    window.__theme = newTheme;
  };

  darkQuery.addListener((e) =&amp;gt; {
    window.__setTheme(e.matches ? window.__DARK : window.__LIGHT);
  });

  window.__setTheme(window.__theme);
  `;
 setHtmlAttributes({ lang: `ko` });
 setPreBodyComponents(&amp;lt;script dangerouslySetInnerHTML={{ __html: script }} /&amp;gt;);
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;그리고 다크모드 버튼을 클릭하면 window객체에 저장해둔 &lt;code class=&quot;language-text&quot;&gt;__setTheme&lt;/code&gt; 함수를 호출하도록 코드를 작성합니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const Layout = ({ location, title, children }) =&amp;gt; {
    ...
	const [theme, setTheme] = useState(null);

	let isDarkMode = false;
	if (typeof window !== &amp;#39;undefined&amp;#39;)
		isDarkMode = theme === window.__DARK;

	const onClickDarkModeButton = useCallback(() =&amp;gt; {
		const newTheme = isDarkMode ? window.__LIGHT : window.__DARK;
		window.__setTheme(newTheme);
		setTheme(newTheme);
	}, [isDarkMode]);

	useEffect(() =&amp;gt; {
		setTheme(window.__theme);
	}, []);

	if (!theme) {
		return null;
	}

	return (
        ...
		&amp;lt;DarkModeButton onClick={onClickDarkModeButton}&amp;gt;{isDarkMode ? &amp;#39;☀️&amp;#39; : &amp;#39;🌙&amp;#39;}&amp;lt;/DarkModeButton&amp;gt;
        ...
	);
};
&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 하면 다크모드 버튼을 클릭할 때 마다 body요소에 &apos;dark&apos;클래스가 생겼다 사라졌다 하는 것을 확인할 수 있습니다.&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/cd172eb41cf4305b2f59faa300cb6587/darklight.gif&quot; alt=&quot;&quot;&gt;&lt;/p&gt;
&lt;h3&gt;다크모드에 따라 스타일 설정하기&lt;/h3&gt;
&lt;p&gt;이제 다크모드에 따른 스타일만 적용해주면 됩니다. 사실 다크모드와 라이트모드에서의 차이점은 색상밖에 없기 때문에 색상만 잘 설정해주면 됩니다.
이 부분은 GPT의 도움을 받았습니다. 제 블로그는 CSS-in-JS라이브러리로 emotion을 사용하고 있는데 글로벌 스타일을 적용할 때 body 요소에 &apos;dark&apos;클래스가 있는지에 따라 다른 스타일을 적용해주는 방법을 사용했습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;import React from &amp;#39;react&amp;#39;;
import { Global, css } from &amp;#39;@emotion/react&amp;#39;;
import Common from &amp;#39;./common&amp;#39;;

// 기본 스타일
const baseStyle = css`
 /* ... 기본 스타일 ... */
`;

// 다크 모드 스타일
const darkStyle = css`
 /* ... 다크 모드 스타일 ... */
`;

const GlobalStyle = () =&amp;gt; {
 // body 클래스에 따라 다른 스타일 선택
 const currentStyle = css`
  ${baseStyle};
  ${document.body.classList.contains(&amp;#39;dark&amp;#39;) ? darkStyle : null};
 `;

 return &amp;lt;Global styles={currentStyle} /&amp;gt;;
};

export default GlobalStyle;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 해주고 다크모드 스타일에 기본 스타일의 색상변수를 다시 설정해주면 됩니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 기본 스타일
const baseStyle = css`
    ...
    --color-text: black;
    --color-background: white;
`;

// 다크 모드 스타일
const darkStyle = css`
 --color-text: white;
 --color-background: black;
`;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br/&gt;
그런데 아뿔싸 ... emotion을 적용하면서 css 변수를 common이라는 자바스크립트 파일을 만들고 그 파일 내에서 객체로 관리하도록 바꾸는 바람에 저 방식이 통하지 않아서 고민을 좀 했습니다.
&lt;p&gt;고민 결과 Common 객체에 lightColor, darkColor를 속성으로 두고, 그 속성 하위에 색상을 정의해두기로 했습니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const Common = {
	...
	lightColor: {
		text: &amp;#39;black&amp;#39;,
		background: &amp;#39;white&amp;#39;,
	},
	darkColor: {
		text: &amp;#39;white&amp;#39;,
		background: &amp;#39;black&amp;#39;,
	},
    ...
};

export default Common;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br/&gt;
그리고 이걸 다시 css변수로 적어줬습니다.
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;// 기본 스타일
const baseStyle = css`
    ...
    --color-text: ${Common.lightColor.text};
    --color-background: ${Common.lightColor.background};
`;

// 다크 모드 스타일
const darkStyle = css`
 --color-text: ${Common.darkColor.text};
 --color-background: ${Common.darkColor.background};
`;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br/&gt;
뭔가 Common 객체로 전역적인 스타일을 한 번에 관리할 수 있는 점이 편리하지만 색상을 추가할 때 css변수로 한 번 더 추가해야 하는 번거로움과 다른 스타일은 Common객체에서 가져다 쓰는 반면 색상은 css 변수를 사용해야 한다는 점이 통일성을 해치는 기분이라 만족스럽지 못합니다. 이 부분에 대해서는 조언이 필요할 것 같습니다... 도와주세요 
&lt;br/&gt;
&lt;h2&gt;3. giscus(댓글)에 다크모드 설정하기&lt;/h2&gt;
&lt;p&gt;헐 이렇게 하니까 다른 부분에는 다크모드가 잘 적용이 되지만 댓글에는 다크모드가 적용이 안돼서 둥둥 떠다닙니다. 댓글에도 다크모드를 설정해줘야 하는데 giscus를 가져다 쓰는 입장에서 어떻게 적용해야 하는지 생각해보니 giscus에서는 다양한 테마를 적용하고 있습니다. 그래서 다크모드 여부에 따라 테마가 변경되도록 구현을 해봤습니다.&lt;/p&gt;
&lt;p&gt;먼저 댓글 컴포넌트에서 테마가 바뀌었다는 것을 감지할 수 있도록 window객체에 리스너를 등록할 수 있도록 바꿔줍니다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const React = require(&amp;#39;react&amp;#39;);

exports.onRenderBody = ({ setPreBodyComponents, setHtmlAttributes }) =&amp;gt; {
 const script = `
  window.__DARK = &amp;#39;dark&amp;#39;;
  window.__LIGHT = &amp;#39;light&amp;#39;;
  
  const darkQuery = window.matchMedia(&amp;#39;(prefers-color-scheme: dark)&amp;#39;);
  const savedTheme = localStorage.getItem(&amp;#39;theme&amp;#39;);

  window.__theme = savedTheme || (darkQuery.matches ? window.__DARK : window.__LIGHT);
  window.__onThemeChange = () =&amp;gt; {};

  window.__setTheme = (newTheme) =&amp;gt; {
    if (newTheme === window.__DARK) {
      document.body.classList.add(window.__DARK);
    } else {
      document.body.classList.remove(window.__DARK);
    }
    localStorage.setItem(&amp;#39;theme&amp;#39;, newTheme);
    window.__theme = newTheme;
    window.__onThemeChange(newTheme);
  };
  darkQuery.addListener((e) =&amp;gt; {
    window.__setTheme(e.matches ? window.__DARK : window.__LIGHT);
  });

  window.__setTheme(window.__theme);
  `;
 setHtmlAttributes({ lang: `ko` });
 setPreBodyComponents(&amp;lt;script dangerouslySetInnerHTML={{ __html: script }} /&amp;gt;);
};&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;br/&gt;
이렇게 테마가 변경될 때 마다 window.__onThemeChange() 함수가 호출되도록 작성해줍니다.
그 다음 댓글 컴포넌트에서 window.__onThemeChange() 함수를 등록해주면 됩니다. 여기서는 __onThemeChange() 함수 내부에서 댓글 테마가 바뀌도록 하여 전체 테마가 바뀔 때 마다 댓글 테마도 바뀌도록 해줬습니다.
&lt;deckgo-highlight-code language=&quot;javascript&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const [commentTheme, setCommentTheme] = useState(null);

useEffect(() =&amp;gt; {
 setCommentTheme(window.__theme === window.__DARK ? &amp;#39;dark&amp;#39; : &amp;#39;preferred_color_scheme&amp;#39;);
 window.__onThemeChange = (theme) =&amp;gt; {
  setCommentTheme(theme === window.__DARK ? &amp;#39;dark&amp;#39; : &amp;#39;preferred_color_scheme&amp;#39;);
 };
}, []);

if (!commentTheme) {
 return null;
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;여기까지 해서 다크모드 적용을 완료하였고 전체적으로 &lt;a href=&quot;https://godsenal.com/posts/gatsby-%EB%B8%94%EB%A1%9C%EA%B7%B8-%EB%8B%A4%ED%81%AC-%ED%85%8C%EB%A7%88-%EC%A0%81%EC%9A%A9%ED%95%98%EA%B8%B0&quot;&gt;이 블로그&lt;/a&gt;를 많이 참고하여 진행을 했습니다.&lt;/p&gt;</content:encoded></item><item><title><![CDATA[Gatsby로 깃허브 블로그 만들기]]></title><description><![CDATA[내 나이 26 ... 드디어 깃허브 블로그를 만들다... 계기 이전에도 기술 블로그를 운영하려는 노력은 꾸준히 해왔다.
맨 처음 마음 먹었을 때는 네이버 블로그를 사용했다. 당시 대학교…]]></description><link>https://klloo.github.io/make-blog/</link><guid isPermaLink="false">https://klloo.github.io/make-blog/</guid><pubDate>Mon, 17 Jul 2023 00:00:00 GMT</pubDate><content:encoded>&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/5b9e5b0ebcc94b90737f13dcf7e64281/d125e/iamold.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 102.17391304347827%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAUCAYAAACNiR0NAAAACXBIWXMAABYlAAAWJQFJUiTwAAAEUklEQVR42k1UXVPiZhjN79np5d70H2x/QKcz26vetM72sl8z9qrTWdvVRUUXFxdBRUVAUZRFVBBIgJCQhPAZwofa9o+cnvfF7fTimSRvkvOc55zzvorXd+F5PXijPkb+AL4/xHgyxGTiwR/zOh2xPPlO1HTm4+FxgvuH8f9qggdeHx6nULxhF0MC+vx4PPYI5j2BjDAYdDDkewE0mXls2kOfBMQ7ATKvJ8DHeSmtVgOdrgXXbcFpm3A7FvqDtgSynaYsy9YxGHbgdlsEG6LTaWE2mzP/VLN70cSHUq2WULy9QrlchN7UYBg11OoVlO4KfK7LH/3JAN2eg27fRm/gwDDrMElEVL1RQ6tloKpWOWkXittuoVQqoKFrUr9u10GbbGf3vhyv0yUIr0LP+/sJ2m1bavz411SOO/L7+PufGWzb4ncEtO0mGeZRr2tyTMOoy5/71E+rVWSJKRpk4nkcbzwHnc0mBPapc5eGTMnSJIEOFIu0r6/yqNWq1MmF0NRik8HAlXqKauhVtCydgENq7XCtTbcJOB5J9sIU0zTR67lQTFNDPn9JLarUyWZZUiOHUgjdRn5PjiWSYFlNsjMwe2AaZkNO0peaTh9G/Mfg920ohqHh4uKMgOqTw4KljoWFb/HixReIxiLSLJNrgo3tmHzWZYRGBOxS4wmNa+g16u1AaZBZJpOGTlNaZCAEXw+u4tmzz7C4uIhIJIwRQy/WTbJIpzI4SZ/h+vpGuipMFLHRqbHr2lDq9TJSySPoxpyF2CE///ITlv54LRlXKkXJQox9Ra2PDhNIHidJ4nQuEQH98YBRq1EOC4qqlnCciHMMlYB1qdvZ+QnC70PI5c6e1mwphZgid5lFuXIDVSvJDeAw+EJnTVN534JSvrsh4AEaDHOxWJCONgkeWFnFVmjrP6dd7g4xYi6XxV4sJlMgMmo7htRTZbAt24RSKl4hRcDb6zx3yw1qahE74S38+MOv2NzYRINxErkTYRdbLpk4xNa7LcnG7djSeZHFSqVMM5tQrgs5ObIAlsaQ3VoggK9ffoPg+jrUyq3MoABwbAPrK2vYDG7CYYO2WDObUo7yXYmmNaB8zJ1T5ENUyE7o6VCzhe9e4fnzz3FwuEcgg7tElYeEpt3hqy9f4tXC92zCrHIDdDimN+pwNxVhNGtQstlTqWGRDFW1jGrpGhEaskGWhatLBrZGTTV54tSp88bqCg5iUdmozdOpQJMKF1mkjhNyQuX8LI3joziqjEcue473G0EcxnYQ3/mA2HYY+9EdHO3v4vhwH2k2zp2ncHGaQjaTQf7jJeLRGPY/RLBNXRu6CuU4sY/4XhSZkwQCb5ax9NvvWFl6zfsVBP5cxirXgm/fYDOwTNbL2A4FsRVcQ5gAsXAYBztRJHb3EOG9OLGUJDtfZFJIJ+PY3dmm4GtyrNDGKsKhDYQ3g2RNI9YCXH9L8GUCrpPRO0RCAnQbu6ztUAiGruFftnMJbx+fxgIAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;iamold&quot;
        title=&quot;&quot;
        src=&quot;/static/5b9e5b0ebcc94b90737f13dcf7e64281/dd45a/iamold.png&quot;
        srcset=&quot;/static/5b9e5b0ebcc94b90737f13dcf7e64281/948cf/iamold.png 138w,
/static/5b9e5b0ebcc94b90737f13dcf7e64281/6b2ea/iamold.png 275w,
/static/5b9e5b0ebcc94b90737f13dcf7e64281/dd45a/iamold.png 550w,
/static/5b9e5b0ebcc94b90737f13dcf7e64281/d125e/iamold.png 737w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;내 나이 26 ... 드디어 깃허브 블로그를 만들다...&lt;/p&gt;
&lt;h4&gt;계기&lt;/h4&gt;
&lt;p&gt;이전에도 기술 블로그를 운영하려는 노력은 꾸준히 해왔다.
맨 처음 마음 먹었을 때는 네이버 블로그를 사용했다. 당시 대학교 4학년이었지만 아무것도 모르던 나는... 그냥 접근성이 제일 좋아서 네이버 블로그로 선택을 했었다.&lt;/p&gt;
&lt;p&gt;스프링으로 막 백엔드 공부를 시작하면서 혼자 진행했던 프로젝트 내용, 알고리즘 문제 풀이, 정보처리기사 공부했던 내용, 면접 대비용으로 자바와 CS공부했던 내용 등을 정리해놨었다. 이제보니 나름 뭘 많이 끄적여놨는지...게시글이 116개가 있다.&lt;/p&gt;
&lt;p&gt;그런데 왐마?! 뭔가 좀 이것 저것 찾아보기 시작하면서 아무도 네이버 블로그를 기술 블로그로 사용하지 않는다는 것을 깨달았다. 또 그 때가 막 네이버 블로그에 일상을 기록하고 소통하는게 유행하기 시작하던 때라...나도 그냥 공부했던 내용 전부 비공개로 전환해놓고 일상 블로그로 돌려버렸다^_^&lt;/p&gt;
&lt;p&gt;그리고는 취업을 했는데 자바스크립트와 클라우드에 관련한 지식 부족으로 ... 업무를 하는데 어려움을 겪었었다. 그래서 공부를 시작하기로 마음 먹고 이 참에 기술 블로그도 다시 해봐야겠다고 생각했다. 그 때는 벨로그를 사용했는데 내 기준 제일 깔끔하고 가독성이 좋아서 선택했었다. 벨로그 메인 트렌드 탭에 올라오는 글들을 읽어보는 것도 재밌었다. 나도 재밌는 글 많이써야지 하고 야심차게 시작을 했는데...&lt;/p&gt;
&lt;p&gt;주로 개념 정리를 하다보니 그냥 여기저기서 긁어온 내용을 누덕누덕 기운 누더기 포스팅만 잔뜩 생겼었다. 당연히 궁금했던 내용, 알아야하는 내용을 찾아보고 이해한 내용을 정리하면서 큰 도움이 됐고 아직도 필요할 때 마다 정리했던 내용을 찾아보기도 하지만 이런걸 꼭 블로그에 써야하나? 하는 생각이 들었다. 그래서 그냥 다 노션으로 옮겨놓고, 앞으로는 이렇게 개념 정리나 혼자 공부한 내용은 노션에 작성을 하고, 프로젝트를 진행하는 과정이나 하여튼 뭔가 혼자 생각해보고 혼자 해결한 과정 같은 것들은 블로그에 기록해두고 싶었다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/d52895fc54b664ba38f119d91faf7535/2e367/latetoolate.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 71.01449275362319%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAADoElEQVR42iWT2U9cZRjG5//wQi80LrWmTS+9NTbGC2xiNahpvZAo2jRpLam1DSmG1oJFqC2LyFraOTMMDOvMMIDMvs+cWc4MAwNtqSytMAtTBC9/voMXT873nbz5vc/7vOfoHL4RPIEJrDNDWO0PiKRshBM2oqlZkZ1EZuFQWtZJetnN0qqPkGonELWSXfGymPOiJh2kFz0sLnnQzbsU5h1GzKM9TE71Ek1aCKsWYgJTtf8V1+ZIpudZEsD49CDV1VVUfXSS6jOnafz5Cr6glaTmFC2gc3gMLLgNuAPD0nX8UMHoGNGEVWAzxJI20QzppQXc/jGGOq8RGW/GPlTP2U8/4KWXX+Hc+a/wh6ZRE7MV4ENcXgWP34A3JNDIqEDN4nJSoNPirgK1ElSnMCstrM53sJc2s581Mdh6gTePvMWxE+9gnuiX0efQOQXo9j6UHBW8QaMARyQjcRkz44+Y5GyW8aex2/u5/+sllDt1KHcvExq9xdXzn/P6kaO8+sZr/NbeSDRuR+f2Cciv4AsZ8IeHCQqkomh8ipQErWX9qOlZQs4BYsM3+bP/Ooa2S/Td+IYP33+X4yeOc/TY29zraCQQnhJgxV0FGDbKyHqBjaBlfDzZXBNtkMxm8MdCKH0tTN2+SNLUhF/fwIOWb7n341m+qHqP2u++xDzejdNtQleBefx63CGFmGS2tpUj83iFUDxKeiVLJKlyt6uDhsvnUH6qxTVwDUvnBQZv1VDz8Uk+qz5Fb3/LIdDhMqJzBfS4gnpisTFyT3Isrz3GFfDKRr0kl9Joy1kcPg89nU3cvniK9quf0PbDaRrqzlBT+zX1Dd/T09vMiLmLBaciwJCRkON3tiLdLMvZYNIzabPIgrziLiYfdZKwuDQOD6Fvq0PffoXB7ib6BnoxmhQmJg3Y5034gxYZWRyG3YNk5pqJjl8nPNtFPOYgu6xKjmFSWpDcaoJMVsZfjPLoUYa1p6sUd0vs7x+wt1emXM6TL2ywk18jHLWgmzHeZNl9h5C5Aad0Ku9tEFdd2GYmUOMBtHQMf8CD1+fG7XERT6j8e3DAgWh3t8hueZtCcVOgfxFVbeiUoVZ85husLrQSdhrYfJZje3uFncI6hdIzKd7in/0icVlSIOBD0zRSqRQejzQRFYp/U5S6fHFdgPbKvzyP8Y960rZfyHjus/V8RYrWD4uKpeeHDsovCvJuh1KpJCOWD587+cq9wO6LvEQgDotPWdKs/AdDvXQRd2Q8cAAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;latetoolate&quot;
        title=&quot;&quot;
        src=&quot;/static/d52895fc54b664ba38f119d91faf7535/dd45a/latetoolate.png&quot;
        srcset=&quot;/static/d52895fc54b664ba38f119d91faf7535/948cf/latetoolate.png 138w,
/static/d52895fc54b664ba38f119d91faf7535/6b2ea/latetoolate.png 275w,
/static/d52895fc54b664ba38f119d91faf7535/dd45a/latetoolate.png 550w,
/static/d52895fc54b664ba38f119d91faf7535/d4c13/latetoolate.png 825w,
/static/d52895fc54b664ba38f119d91faf7535/2e367/latetoolate.png 1066w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;나 스스로도 왜 이제 와서... 라는 생각이 들었지만 몰라... 고민 말고 다시 시작해보기로 했다.
왜 깃허브 블로그로 다시 시작을 했냐면 그냥 멋져서 그렇다.&lt;/p&gt;
&lt;h4&gt;플랫폼 선정&lt;/h4&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/17e30361762dc704275f0a045ebb7ffc/78612/gatsbyy.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 39.85507246376812%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAICAYAAAD5nd/tAAAACXBIWXMAABYlAAAWJQFJUiTwAAABUUlEQVR42nWSTUtCQRSG/Yv+BBcuQlyIm0QXItGiRaEpRQuxFhqkNyKruyhQklzYRdJFSlRQZJf8CkKs+/WEg7e8WgOH886ccx5meMfFdFmWxbyeZNM0HbW/+meXyxafY43nOxX1qYdlWgtgwzAE3I75MwdQ+9I5yVyyEymIuDq9EcXBYECxWERVVbGfDOq6LnStVvvRs7cVwNvrBzIrR4TcKZbdSdaWdtHGBvFEnHQ6jSRJlEolcrkc0WiUSqVCOBwmn89TrVap1+uMRqNfYEt5pJA6J7d+xlbogMPtC8YfGonNOKlkCo/HQyAQwO/3E4vFCAaDeL1eIpEIPp9PZPsFAqhrBmVJYX9DZm/1mHq5JRr6vT6yLDMcDmk0GjSbTTqdjsiKotBut8lms0I7gDb05f6N3uv71EanKf+52+12F01ZGDKd7trf56+Y1GZN+Qb8DkQRoZ7UTwAAAABJRU5ErkJggg==&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;gatsbyy&quot;
        title=&quot;&quot;
        src=&quot;/static/17e30361762dc704275f0a045ebb7ffc/dd45a/gatsbyy.png&quot;
        srcset=&quot;/static/17e30361762dc704275f0a045ebb7ffc/948cf/gatsbyy.png 138w,
/static/17e30361762dc704275f0a045ebb7ffc/6b2ea/gatsbyy.png 275w,
/static/17e30361762dc704275f0a045ebb7ffc/dd45a/gatsbyy.png 550w,
/static/17e30361762dc704275f0a045ebb7ffc/d4c13/gatsbyy.png 825w,
/static/17e30361762dc704275f0a045ebb7ffc/99f37/gatsbyy.png 1100w,
/static/17e30361762dc704275f0a045ebb7ffc/78612/gatsbyy.png 1260w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;보통 깃허브로 블로그를 만들 때 제일 유명한게 Jekyll과 Gatsby였는데 Gatsby가 리액트 기반이라고 해서 관심이 갔다. 안그래도 막막한 블로그 만들기... 조금이라도 익숙한 환경에서 진행을 해보고 싶었다.&lt;/p&gt;
&lt;p&gt;그래서 관련된 내용을 찾아보니 Gatsby가 유용한 플러그인들도 많이 제공을 하고, 성능도 더 좋다고 하길래 더 고민없이 Gatsby로 선택했다! Jekyll은 사용해보지 않아서 비교는 못해보겠지만 확실히 리액트 기반이라 큰 어려움 없이 진행할 수 있었던 것 같다. 아직 SSG에 대한 내용이나 Gatsby프레임워크, GraphQL을 몰라서 반도 모르고 사용한 느낌이라 이 부분들에 대해서도 더 찾아봐야할 것 같다.&lt;/p&gt;
&lt;h4&gt;깃허브 페이지로 블로그 올리기&lt;/h4&gt;
&lt;p&gt;먼저 틀만 만들어진 블로그를 Github Pages로 올려보고 싶었다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;1. Gatsby 프로젝트 생성&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. Github Repository를 생성하고 Gatsby 프로젝트와 연결&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. Github Pages 설치 및 배포 설정&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;그 과정은 이 순서로 진행을 했다. Gatsby는 리액트 프레임워크로 SSG(Static Site Generator, 정적 사이트 생성기)이다. 여기서 정적 사이트란 HTML, CSS, JavaScript로만 만들어진 사이트를 의미한다.&lt;/p&gt;
&lt;p&gt;그래서 이걸로 어떻게 블로그를 만드는거냐면 내가 Markdown으로 글을 쓰면, 이걸 SSG가 HTML코드로 변환을 해서 정적 사이트로 만들어 주는데, 이 만들어진 정적 사이트를 블로그로 사용하는 것이다. 이렇게 하면 정적 파일만 배포하면 되기 때문에 별도의 서버를 운영할 필요가 없다는 장점이 있다.&lt;/p&gt;
&lt;p&gt;아무튼 이렇게 블로그를 만들었으니, 배포를 해야하는데 이 때 사용하는 것이 Github Pages이다. Github pages는 github에서 제공하는 정적 웹사이트 호스팅 서비스로, 자신의 repository내용으로 웹페이지를 구동할 수 있게 해준다.&lt;/p&gt;
&lt;p&gt;자세한 진행 과정은 &lt;a href=&quot;https://devfoxstar.github.io/web/github-pages-gatsby&quot;&gt;이 블로그&lt;/a&gt;를 보고 진행하였다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 498px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/1d2c8e790c3494081fbeb9b4ab06c4d9/79e1b/originblog.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 168.84057971014494%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAiCAYAAABfqvm9AAAACXBIWXMAABYlAAAWJQFJUiTwAAAEmElEQVR42qVWS0/jVhT2L2Nf2DBdICTQFAmQOj9hRkhV1S4qFlVFQVRI3fQ1s6SLDlRIFWphKqYaJhAeSZw4sWPHdhznTZz313NO4vAcGM04OrnX9rnfPb7nO9+9Cu65+v2+2ENXf2j8rxSLRaytreHw8BAHBwfY39+XdmdnB5qmQdd1rK+vY3Pzd5zHzpFIJLD1cguRSATH0WO4rjuanC9FVVXMz89jcXERExMTWFhYwPj4J5iensbY2BgBbeLJ508wNzeHmZkZfProEZ4+fYapqSlMTk4iGo0KUK/XGwB2Oh0cHR0hnU6jXC6j0WjA8zz4vo/d3V1py+UKCoUCTNOEbTu4qNfhOo74dbvda5+vnJ6cUkTjmJ2dxfLyMpaWlrC9vX1rDa+u5bv6ApjL2VhdXcXKygqt1Q94/PgzbGxsyEuOPgTtsfX68mlyP2xvAd7MWJ0+Jwiao9kvAW6D3mXKKAJy6vW6IwJ86CURZmKn0JIJeZA1LdiOS3TIUyJ8pDMGLFoWbtkyepZ8cigWS+LnsJ9fRN4ryDOlVrDw/Luv8NPyM1TyWeQcD8mUBiNrisUTSbpPQ0tnoKopqMkUYnF1OIE+nEyXQGq0XIqhxfHlN99i6YuvET+LwvV8ZIwstQWZPUc0cfMeTMuGSYP5Gfd1wxxG78jEPkU5+uQwU8wpnk1LpZBzfUSNIuJWCUeZAg41Dye6j/9UF6fZIo6pf0JtzCxKonjtJSlXAYN2B8cZDwcxixx9tDs9BK0Omu0uGbXUD6jfanfEN3w3SGyYlOFNSI1qo41irSntB2W5/5CK9G/aMABc3l8HpPtuSFoy6fduEPk9ZezOSvnYSylUA/zxJoM3qTwiaQ9bb3UcqA724zZekf2bcMQ88rtLDG4BVmjxtyJZ7BybiBAVXr418HwvQa2OvZhN73T8/HccTuni/QCbQQDfdVAplVAgfatWSvduB7csfBcCdkkUGgQatFpotdrEtbZkL0zSZWb7t+TqrmiVZrOFlJaRmuQC5zLTRQCsQa1SmXEt60Z2JBzsb1o5KbmUlpZ6D4LBGiusfeyc0Q2pW1YTdswTMN8zmEnqwu+5zYpZAsptmyuGMEabFCNrFAlHw4MYIENFzxFwNPzOyFoyWB8qEPuxcb9cqaJWq4vUNWnZlGq1JmCDT7BGasLO3HcIlFXFdgbKw5PkSGFc15Mx4ZdpaZ3U/gIK//FgfsCAalKTKLllabpahtc7H1kpffTfTZ1R9km+GiRBhldDLWjB8usiUyxRLE2mX4NNhL5odlCqN68F2B/+rk4ogHa5ge//PJVK+XVPxYtXSbzYV/HbPwlsvtbwC1XJj3+dSfnJCeGhSmlRZvIk+36pgjIlqFAqo9khESVj0ne7PRHR7j1b51WCK8wj3rU429VaDZVq9ePUJqBKYUCftkA+wzCvuFqYMkwR3nz4GW+R4VbJ/h7xrkT+tu3KfXg4UPikwKxn6sjORpXAvDs7j9PxLSEUYmDmm5DbMMWft1TmYbhXM7lHgCGJeQCftpxhvQ5IbEsZ8tbKUZnkw5Ny7fM4m05hPDlXCQP+D5bF/egPmKDqAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;originblog&quot;
        title=&quot;&quot;
        src=&quot;/static/1d2c8e790c3494081fbeb9b4ab06c4d9/79e1b/originblog.png&quot;
        srcset=&quot;/static/1d2c8e790c3494081fbeb9b4ab06c4d9/948cf/originblog.png 138w,
/static/1d2c8e790c3494081fbeb9b4ab06c4d9/6b2ea/originblog.png 275w,
/static/1d2c8e790c3494081fbeb9b4ab06c4d9/79e1b/originblog.png 498w&quot;
        sizes=&quot;(max-width: 498px) 100vw, 498px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;처음엔 이런 모습이었다.(모바일 화면) 저 kyle mathews라는 분이 Gatsby 만든 사람이라고 한다... 안녕하세요 대단하십니다.&lt;/p&gt;
&lt;h4&gt;블로그 디자인 및 기능 추가&lt;/h4&gt;
&lt;p&gt;깃허브 블로그의 가장 큰 장점은 모든걸 커스터마이징할 수 있다는 것이다. 깃허브 블로그를 선택한 이유가 멋있어서... 라고 했는데 이 점이 제일 멋있는 것 같다.&lt;/p&gt;
&lt;p&gt;먼저 원했던 기능들을 추가한 다음, 디자인을 추가했다.&lt;/p&gt;
&lt;h5&gt;카테고리 기능&lt;/h5&gt;
&lt;p&gt;카테고리 추가는 그냥 마크다운 문서 가장 위쪽에 있는 메타데이터를  &lt;code class=&quot;language-text&quot;&gt;frontmatter&lt;/code&gt; 라고 하는데 그냥 여기에 category 항목만 추가하면 됐다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/09b8c4da44f5f8c31f020b78b3482e03/c0255/frontmatter.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 25.362318840579707%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA0UlEQVR42o2P227DIBBE8x1pDMTAcrGNsUNza6u2Uvr/nzQFZFnOWx6OZgeNdocd5xy+D5DkoGQLUhJWq4rREi4rqRaeNBwpeKPRbSg+OELZU9hxIWDmD9B4xnn0eFwm/L5H3OKQ6ZEGj6mz+JxD1eAMTr2r76M3iJkys3Uh47DpCzZeoO2IFHr8pIj7NEDnxvtDg0PDFl1Y5oaxqm/Zrw2FPuZ2V7j0jcdfBNERwZr6vRIQBbFh47nga+ZpYRdmKONwCnvIluWLDCxf55vgq/wDorCPUPfKlSsAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;frontmatter&quot;
        title=&quot;&quot;
        src=&quot;/static/09b8c4da44f5f8c31f020b78b3482e03/dd45a/frontmatter.png&quot;
        srcset=&quot;/static/09b8c4da44f5f8c31f020b78b3482e03/948cf/frontmatter.png 138w,
/static/09b8c4da44f5f8c31f020b78b3482e03/6b2ea/frontmatter.png 275w,
/static/09b8c4da44f5f8c31f020b78b3482e03/dd45a/frontmatter.png 550w,
/static/09b8c4da44f5f8c31f020b78b3482e03/d4c13/frontmatter.png 825w,
/static/09b8c4da44f5f8c31f020b78b3482e03/c0255/frontmatter.png 920w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;그리고 이걸 활용해서 카테고리 목록을 가져왔다. graphql 초면이라 이 부분은 구글링 했다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;graphql&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;categories: allMarkdownRemark(limit: 2000) {
    group(field: frontmatter___category) {
        fieldValue
        totalCount
    }
}&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;아무튼 이렇게 가져와서&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;const categories = [{fieldValue: ALL_NAME, totalCount: allPosts.length}, ...data.categories.group]&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 전체보기 카테고리까지 추가한 다음 화면에 뿌려줬다.&lt;/p&gt;
&lt;p&gt;그 다음 카테고리를 선택하면 페이지 전환 없이 그냥 포스트 목록에서 제목에 검색 키워드가 포함되는 포스트만 조회되도록 하고싶었다. 이 부분은 따로 질의 하지 않고 그냥 전체 포스트 목록에서 걸러주는 식으로 만들었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;useEffect(() =&amp;gt; {
  if (curCategory === ALL_NAME) {
    setPosts([...allPosts]);
    return;
  } setPosts([...allPosts.filter((post)=&amp;gt;post.frontmatter.category === curCategory)]);
}, [curCategory]);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게 카테고리가 바뀔 때 마다 다른 포스트들을 보여주도록 했다.&lt;/p&gt;
&lt;h5&gt;검색 기능&lt;/h5&gt;
&lt;p&gt;검색도 카테고리와 마찬가지로 전체 포스트 목록에서 키워드로 걸러주는 방식으로 만들었다.&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;js&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;  const searchProc = useCallback((e) =&amp;gt; {
    e.preventDefault();
    // 검색 키워드가 없으면 전체보기 카테고리로 이동
    if(!keyword || !keyword.trim()) {
      setCurCategory(ALL_NAME);
      setPosts([...allPosts]);
      return;
    }
    setPosts([...allPosts.filter((post)=&amp;gt; {
      // 키워드가 포스팅의 제목 또는 설명에 포함이 되어야 하고 현재 카테고리가 전체보기거나, 전체보기가 아니라면 해당 카테고리에 속하는 게시글이어야 한다. (카테고리 별로 검색)
      if ((post.frontmatter.title?.includes(keyword) || post.frontmatter.description?.includes(keyword))) {
        if (curCategory !== ALL_NAME) 
          return post.frontmatter.category === curCategory;
        return true;
      }
  })])
  }, [keyword, curCategory]);&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;이렇게... 했어욥&lt;/p&gt;
&lt;p&gt;대충 이 정도만 추가하고 본격적으로 꾸미기 시작했다. 일단 나는 최대한 심플하고 깔끔하게 만들고 싶었다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/0127c260b77f35d06ce90db0673ad16e/a2ef2/mynaverblog.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 70.28985507246377%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAABYlAAAWJQFJUiTwAAACIklEQVR42q2T30tTYRjHz3/UVRcJ0T/QRYUXRWB10U0ohaCBsAwr3RwGlkTJ0DJSSprGSvej4Zruh2dzRxf2QyWKJumctUXu7Gw7+3Teo6sWXWT5wJf3eR8O3/d5nu/3SJqmkctmKapbVCoVdF3/J5TLZUqlElKxWERVVYoGsSiIuzhL4qzmu4AkuhLYq5AKBRVNK/woZDIZCka3omNNze+e8PeCGFnspLKzm7+N6pQSexwmoaoWzM6q+zRR7dJQr+a+g+3vfuZqPm9ymIS6Xv5vYaoPSWJLy6lN/IEZ4oko71PrbKytsrQgk0zIuCddpNPrrCwqJEJ+3izEmI9F+LKZZuV1koQcZi4S5K0SMr0oaSWdwIxMj/USj50DeJ4HmA294EaXBVt3FycbTiFPB1mMeng22Mkd60UO7t9HwDuB+5EDxX2XwMh1wqO9hjMKSIJ1qM+K3dKEa6yf4cEe4vE4F5obaWlrxnrlGqGpILkPCrHxPoZv2zhUdwD/xBPczgfklnykZkdJRcaMuQ1j57e+Mey4idPRgeu+HSXsxuv1crT+CKcbTtDaeB5/MIz7Xi9nDtdhOVvPseNNeCa9+F39JP1DZF750FZlQzSDUDXMq0SnkaeeMuMbJ7vxkUg0QntHO7d67Ax02pmdSzDpfIjtchuOq610t5zjpRJH+5pi7d08ibCPz5+Wt20j1BX/4J8UqzV8qcYJupGLmmnqX4z9HWKCAmTncr+3AAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;mynaverblog&quot;
        title=&quot;&quot;
        src=&quot;/static/0127c260b77f35d06ce90db0673ad16e/dd45a/mynaverblog.png&quot;
        srcset=&quot;/static/0127c260b77f35d06ce90db0673ad16e/948cf/mynaverblog.png 138w,
/static/0127c260b77f35d06ce90db0673ad16e/6b2ea/mynaverblog.png 275w,
/static/0127c260b77f35d06ce90db0673ad16e/dd45a/mynaverblog.png 550w,
/static/0127c260b77f35d06ce90db0673ad16e/d4c13/mynaverblog.png 825w,
/static/0127c260b77f35d06ce90db0673ad16e/99f37/mynaverblog.png 1100w,
/static/0127c260b77f35d06ce90db0673ad16e/a2ef2/mynaverblog.png 1970w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;이게 내 네이버 블로그인데 뭔가 이런 느낌으로 만들고 싶었다. 뭐... 아무것도 없어보이긴 하지만 그래도 있을 기능 다 있고도 엄청 깔끔한 점이 맘에 든다.&lt;/p&gt;
&lt;p&gt;그리고 &lt;a href=&quot;https://zoomkoding.com/college-timetable-development/&quot;&gt;이 블로그&lt;/a&gt;도 많이 참고했다.
사실 거의 그대로 만든 느낌인데 개인적으로 카드 형태의 목록을 좋아해서 포스트 목록은 카드 형식으로 만들었다!&lt;/p&gt;
&lt;p&gt;제일 많이 신경 쓴 부분은 폰트인데 폰트는 &lt;a href=&quot;https://noonnu.cc/font_page/448&quot;&gt;ibm 폰트&lt;/a&gt;를 사용했다.
처음에는 &lt;a href=&quot;https://noonnu.cc/font_page/452&quot;&gt;paybook 폰트&lt;/a&gt;를 사용했었는데 적당히 둥글고도 단정한 느낌이 좋았지만 ibm폰트가 더 깔끔하고 가독성이 좋은 느낌이라 이걸로 결정했다! 하지만 언제 또 바뀔지 모른다.. 결정느림보에게 이렇게 자유도 높은 플랫폼은 힘들어요...&lt;/p&gt;
&lt;h4&gt;댓글 추가하기&lt;/h4&gt;
&lt;p&gt;무릇 블로그라면 댓글 기능이 있어야한다.&lt;/p&gt;
&lt;p&gt;보통 Utterances를 많이 사용하는 것 같은데 나는 giscus라는 것을 사용했다. 테마도 다양했고 반응 기능, 정렬 기능, 답글 기능 등 Utterances보다 많은 기능을 제공하고 있었기 때문이다!&lt;/p&gt;
&lt;p&gt;giscus는 일단 댓글 전용 리포지토리를 만들고, Discussions를 활성화 시킨 다음, &lt;a href=&quot;https://giscus.app/ko&quot;&gt;이 문서&lt;/a&gt;에 나온대로 진행하면 된다. 댓글 기능은 포스트 별로 discussion을 생성하고, 해당 discuusion에 달린 댓글을 포스트에 보여주는 방식인 것 같았다.&lt;/p&gt;
&lt;p&gt;이 문서의 마지막에 페이지에 넣으라고 스크립트를 제공해주는데 이걸 어떻게 적용시키지...? 싶었다. 그래서 찾아보니 &lt;code class=&quot;language-text&quot;&gt;@giscus/react&lt;/code&gt; 라는 패키지가 있었다. 이 패키지를 설치하고 &lt;a href=&quot;https://github.com/giscus/giscus-component&quot;&gt;여기서&lt;/a&gt; 하라는대로 컴포넌트를 추가해줬다!&lt;/p&gt;
&lt;deckgo-highlight-code language=&quot;html&quot;  &gt;
          &lt;code slot=&quot;code&quot;&gt;&amp;lt;Giscus
    id=&amp;quot;comments&amp;quot;
    repo=&amp;quot;klloo/blog-comments&amp;quot;
    repoId=&amp;quot;&amp;quot;
    category=&amp;quot;&amp;quot;
    categoryId=&amp;quot;&amp;quot;
    mapping=&amp;quot;pathname&amp;quot;
    strict=&amp;quot;0&amp;quot;
    reactionsEnabled=&amp;quot;1&amp;quot;
    emitMetadata=&amp;quot;0&amp;quot;
    inputPosition=&amp;quot;bottom&amp;quot;
    theme=&amp;quot;preferred_color_scheme&amp;quot;
    lang=&amp;quot;ko&amp;quot;
    crossorigin=&amp;quot;anonymous&amp;quot;
    async
/&amp;gt;&lt;/code&gt;
        &lt;/deckgo-highlight-code&gt;
&lt;p&gt;giscus에서 제공해주는 스크립트의 속성명(케밥케이스)과 컴포넌트에 넣어야하는 prop이름(카멜케이스)이 다르기 때문에 주의해야 한다. 이 사항은 &lt;code class=&quot;language-text&quot;&gt;@giscus/react&lt;/code&gt; 패키지 설명에도 나와있긴하다.&lt;/p&gt;
&lt;p&gt;그러면 댓글 기능 완성이다. 그런데 이렇게만 하면 내가 포스트들을 일일이 확인해야 댓글이 달렸는지 알 수 있다. 그래서 댓글이 달리면 슬랙으로 알림이 오도록 설정해줬다.&lt;/p&gt;
&lt;p&gt;먼저 슬랙에 워크스페이스를 만들고 슬랙 봇을 생성해준다. 그리고 댓글 전용 repository에 Actions를 추가해준다. 그럼 끝이다&lt;/p&gt;
&lt;p&gt;github actions는 github에서 제공하는 CI/CD를 위해 제공되는 서비스로 repository에서 에서 어떤 이벤트가 발생했을 때 특정 작업이 일어나게 하거나 주기적으로 어떤 작업들을 반복해서 실행시킬 수도 있다. 그래서 댓글이 달리면(discussion이 생성되거나, discussion에 댓글이 달렸을 경우), 슬랙으로 알림을 보낼 수 있도록 설정해주면 되는 것이다.&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/bf44b554a1e617c1f0b5bcd1abcc7b97/d7ceb/slackcomment.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 47.10144927536232%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAJCAYAAAAywQxIAAAACXBIWXMAABYlAAAWJQFJUiTwAAABCElEQVR42p2RW2vCQBCF8///SaEv/QO2Ul9K9VGkBRONunHjJRdzT3a/TgQfpKWoA2eHZZdzZs5xRi8jJu8TVLDGXyzYak2S5RhjuFTXdVf3/8qxxpKmGVN3zfdSMVdH3PDE4VTxSDlFVpJnBcFWc4xiqqq+a6JfhG/PQ8bDsayqWPlLdKiJkoyqbh4jNJ0hSU7MPMXXQuGpA9N1TJiW5w/2XsKmaijyQkLRaL07k3ci0gth7W3ohcsaI5s5r08DPgcfBJsVvjtHq0C8TCSoHCukN0H8tmWDkTxkwpo4TplvdnjBHj+MmKkYFRWPedgfbduSy8hl3QrEArGhlt6n3b9d+l+w9trlH+EavUn9vw4vAAAAAElFTkSuQmCC&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;slackcomment&quot;
        title=&quot;&quot;
        src=&quot;/static/bf44b554a1e617c1f0b5bcd1abcc7b97/dd45a/slackcomment.png&quot;
        srcset=&quot;/static/bf44b554a1e617c1f0b5bcd1abcc7b97/948cf/slackcomment.png 138w,
/static/bf44b554a1e617c1f0b5bcd1abcc7b97/6b2ea/slackcomment.png 275w,
/static/bf44b554a1e617c1f0b5bcd1abcc7b97/dd45a/slackcomment.png 550w,
/static/bf44b554a1e617c1f0b5bcd1abcc7b97/d4c13/slackcomment.png 825w,
/static/bf44b554a1e617c1f0b5bcd1abcc7b97/99f37/slackcomment.png 1100w,
/static/bf44b554a1e617c1f0b5bcd1abcc7b97/d7ceb/slackcomment.png 1446w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;p&gt;자세한 과정은 &lt;a href=&quot;https://jjam89.tistory.com/287&quot;&gt;이 블로그&lt;/a&gt;를 참고했고, 이렇게 해주면 슬랙으로 알림이 잘 오는걸 확인할 수 있다!&lt;/p&gt;
&lt;h4&gt;Google Search Console 등록하기&lt;/h4&gt;
&lt;p&gt;이렇게 블로그도 만들고 댓글 기능도 만들었는데 아무도 안찾아오면 외롭고 슬프니까 Google Search Console에 등록해준다.&lt;/p&gt;
&lt;p&gt;이 과정은 Gatsby 플러그인을 사용해서 robots.txt과 sitemap을 생성하고, Google Search Console에 sitemap을 등록해주기만 하면 된다.&lt;/p&gt;
&lt;p&gt;등록하는 과정은 &lt;a href=&quot;https://janeljs.github.io/blog/google-search-console/&quot;&gt;이 블로그&lt;/a&gt; 내용을 참고하였다. 일단 따라서 등록은 했는데... 잘 된건지 모르겠다. 보통 노출되는데 며칠 걸린다고 하니까 좀 기다려봐야겠다&lt;/p&gt;
&lt;p&gt;+ 하루만에 노출이 되고 있는 것을 확인했다!&lt;/p&gt;
&lt;p&gt;&lt;span
      class=&quot;gatsby-resp-image-wrapper&quot;
      style=&quot;position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;&quot;
    &gt;
      &lt;a
    class=&quot;gatsby-resp-image-link&quot;
    href=&quot;/static/21fa6a716f6034cfbaa95add0ea01313/332b4/googlesite.png&quot;
    style=&quot;display: block&quot;
    target=&quot;_blank&quot;
    rel=&quot;noopener&quot;
  &gt;
    &lt;span
    class=&quot;gatsby-resp-image-background-image&quot;
    style=&quot;padding-bottom: 63.04347826086957%; position: relative; bottom: 0; left: 0; background-image: url(&apos;data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAANCAYAAACpUE5eAAAACXBIWXMAABYlAAAWJQFJUiTwAAABKElEQVR42s1Ra0/DMBDr//+VIChtx9q830nNJWvHJjZgEh84yTolcZyz0ym2wBqFWkIIcM5bl1Ii59z213W9QikF3jlY62F9ImTab1R0kjE4axpRCEmCn6LOecQYG1JKCCE2+BDgvUcgRB8QYkbZFDtsVacJRHT0ciVXKK1pCrutA4wxUEpBa0P8glvVlUI2ysmKVgZGW4rAIaeCetZ6Xq8urRcxxEiTk4N93V2yDq8cb08zDv2C6YWBTRpLr6GZO2dXndS+1x7JecLLd8dxxDCM1KfWGeMtT0Y510xrPx6PZFnjXp0Fa6aafksKjphOFm798I4fBWvGfW8xPL9jIsvLqKBmj5LuX/5WsFrmM8d8YJDcIIWCYNKXD3lAEL+y9JDgX9T/F/wAc/UAviaoBeEAAAAASUVORK5CYII=&apos;); background-size: cover; display: block;&quot;
  &gt;&lt;/span&gt;
  &lt;img
        class=&quot;gatsby-resp-image-image&quot;
        alt=&quot;googlesite&quot;
        title=&quot;&quot;
        src=&quot;/static/21fa6a716f6034cfbaa95add0ea01313/dd45a/googlesite.png&quot;
        srcset=&quot;/static/21fa6a716f6034cfbaa95add0ea01313/948cf/googlesite.png 138w,
/static/21fa6a716f6034cfbaa95add0ea01313/6b2ea/googlesite.png 275w,
/static/21fa6a716f6034cfbaa95add0ea01313/dd45a/googlesite.png 550w,
/static/21fa6a716f6034cfbaa95add0ea01313/d4c13/googlesite.png 825w,
/static/21fa6a716f6034cfbaa95add0ea01313/99f37/googlesite.png 1100w,
/static/21fa6a716f6034cfbaa95add0ea01313/332b4/googlesite.png 1826w&quot;
        sizes=&quot;(max-width: 550px) 100vw, 550px&quot;
        style=&quot;width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;&quot;
        loading=&quot;lazy&quot;
        decoding=&quot;async&quot;
      /&gt;
  &lt;/a&gt;
    &lt;/span&gt;&lt;/p&gt;
&lt;h4&gt;향후 계획&lt;/h4&gt;
&lt;p&gt;&lt;strong&gt;1. about 페이지 추가&lt;/strong&gt;
&lt;br/&gt;
우측 상단에 버튼만 덩그러니 만들어 놨는데... 당장은 안할 것 같지만 언젠가 나에 대한 내용으로 차차 채워 볼 예정이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;2. 페이징 기능 추가&lt;/strong&gt;
&lt;br/&gt;
게시글이 많아진다면 페이징 기능도 추가해봐야할 것 같다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;3. 블로그 홈 배너 위치에 있는 내용 수정&lt;/strong&gt;
&lt;br/&gt;
뭐 넣어야할 지 몰라서 일단 갤러리 뒤져서 아무 사진이나 넣어뒀는데 나쁘지 않길래 그냥 뒀다. 좋은 아이디어가 떠오르면 바로 수정할 예정이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;4. SEO 최적화&lt;/strong&gt;
&lt;br/&gt;
아직 검색엔진과 검색엔진 최적화에 대한 개념이 많이 부족하기도 하고 작성한 글도 없으니...일단은 미뤄두지만 조만간 공부해보고 적용해볼 예정이다.&lt;/p&gt;
&lt;p&gt;&lt;strong&gt;5. 게시물 목차(TOC) 구현&lt;/strong&gt;
&lt;br/&gt;
그 보통 개발 블로그 보면 게시물 옆에 졸졸 따라다니는 목차가 있는데 나도 필요할 것 같다. 이건 이번주 안에 추가할 예정이다.&lt;/p&gt;</content:encoded></item></channel></rss>