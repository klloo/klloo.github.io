{"componentChunkName":"component---src-pages-blog-post-js","path":"/swr-pagination/","result":{"data":{"site":{"siteMetadata":{"title":"klloo"}},"markdownRemark":{"id":"e066ddcc-cf25-5691-afbb-d2a3cec1b88c","excerpt":"무한 스크롤 ? 무한 스크롤이란 사용자가 페이지 하단에 도달했을 때, 콘텐츠가 계속 로드되는 사용자 경험 방식입니다. 페이지를 클릭하면 다음 페이지 주소로 이동하는 페이지네이션(Pagination…","html":"<h3>무한 스크롤 ?</h3>\n<p>무한 스크롤이란 사용자가 페이지 하단에 도달했을 때, 콘텐츠가 계속 로드되는 사용자 경험 방식입니다. 페이지를 클릭하면 다음 페이지 주소로 이동하는 페이지네이션(Pagination)과 달리, 한 페이지에서 스크롤만으로 새로운 콘텐츠를 보여주게 되므로 많은 양의 콘텐츠를 스크롤하여 볼 수 있는 장점이 있습니다.</p>\n<p>하지만 스크롤을 내릴때 마다 네트워크 요청이 이루어지므로 페이지 성능이 느려질 수 있다는 단점도 있습니다. 그럼에도 개발중인 내용 중 로그를 보여주는 페이지가 있는데, 이 경우에는 페이지네이션 기능보다는 계속 스크롤하며 로그를 확인하는 무한 스크롤 방식이 더 사용자들이 더 쉽게 사용할 수 있을 것 같아 이 방식을 구현해보기로 했습니다!</p>\n<h3>useSWRInfinite</h3>\n<p>useSWRInfinite은 SWR에서 제공하는 훅으로, 하나의 훅을 사용해서 많은 요청을 트리거 할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> useSWRInfinite <span class=\"token keyword\">from</span> <span class=\"token string\">'swr/infinite'</span>\n\n<span class=\"token comment\">// ...</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> data<span class=\"token punctuation\">,</span> error<span class=\"token punctuation\">,</span> isLoading<span class=\"token punctuation\">,</span> isValidating<span class=\"token punctuation\">,</span> mutate<span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">,</span> setSize <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useSWRInfinite</span><span class=\"token punctuation\">(</span>\n  getKey<span class=\"token punctuation\">,</span> fetcher<span class=\"token operator\">?</span><span class=\"token punctuation\">,</span> options<span class=\"token operator\">?</span>\n<span class=\"token punctuation\">)</span></code></pre></div>\n<p>useSWR과 유사하게 생겼으며 파라미터와 반환값에 대한 설명은 아래와 같습니다.</p>\n<p><strong>파라미터</strong></p>\n<ul>\n<li><code class=\"language-text\">getKey</code>: 인덱스와 이전 페이지 데이터를 받고 페이지의 키를 반환하는 함수</li>\n<li><code class=\"language-text\">fetcher</code>: useSWR의 fetcher 함수와 동일</li>\n<li><code class=\"language-text\">options</code>: useSWR이 지원하는 모든 옵션을 받음. 네 개의 추가 옵션을 포함:</li>\n<li><code class=\"language-text\">initialSize = 1</code>: 초기에 로드해야 하는 페이지의 수</li>\n<li><code class=\"language-text\">revalidateAll = false</code>: 항상 모든 페이지의 갱신 시도</li>\n<li><code class=\"language-text\">revalidateFirstPage = true</code>: always try to revalidate the first page</li>\n<li><code class=\"language-text\">persistSize = false</code>: 첫 페이지의 키가 변경될 때, 페이지 크기를 1(initialSize가 설정된 경우 initialSize)로 초기화하지 않음</li>\n<li><code class=\"language-text\">parallel = false</code>: 여러 페이지를 병렬적으로 동시에 불러옴</li>\n</ul>\n<p><strong>반환 값</strong></p>\n<ul>\n<li><code class=\"language-text\">data</code>: 각 페이지의 응답 값의 배열</li>\n<li><code class=\"language-text\">error</code>: useSWR의 error와 동일</li>\n<li><code class=\"language-text\">isLoading</code>: useSWR의 isLoading과 동일</li>\n<li><code class=\"language-text\">isValidating</code>: useSWR의 isValidating과 동일</li>\n<li><code class=\"language-text\">mutate</code>: useSWR의 바인딩 된 뮤테이트 함수와 동일하지만 데이터 배열을 다룸</li>\n<li><code class=\"language-text\">size</code>: 가져올 페이지 및 반환될 페이지의 수</li>\n<li><code class=\"language-text\">setSize</code>: 가져와야 하는 페이지의 수를 설정</li>\n</ul>\n<h4>사용 방법</h4>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">getKey</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">pageIndex<span class=\"token punctuation\">,</span> previousPageData</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>previousPageData <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>previousPageData<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 끝에 도달</span>\n <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">/users?page=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>pageIndex<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">&amp;limit=10</span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// SWR 키</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> <span class=\"token punctuation\">{</span> data<span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">,</span> setSize <span class=\"token punctuation\">}</span> <span class=\"token operator\">=</span> <span class=\"token function\">useSWRInfinite</span><span class=\"token punctuation\">(</span>getKey<span class=\"token punctuation\">,</span> fetcher<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위와 같이 사용할 수 있으며 useSWR과의 가장 큰 차이점은 <code class=\"language-text\">getKey</code>함수인 것 같습니다. 이 함수는 현재페이지의 인덱스와 이전 페이지의 데이터를 받아서 새로운 키를 반환함으로써 인덱스 기반 및 커서 기반 페이지네이션 API를 지원할 수 있게 됩니다.</p>\n<p>useSWRInfinite를 사용해봤을 때, <code class=\"language-text\">setSize</code>를 이용해서 size를 변경시켜주면, <code class=\"language-text\">getKey</code>함수가 호출되어 다음 페이지의 데이터를 로딩해주고 있는 것 같았습니다.</p>\n<p>예를들어 <code class=\"language-text\">setSize(3)</code>을 호출하여 총 3페이지에 해당하는 데이터를 가져와야 한다면 <code class=\"language-text\">pageIndex</code>를 0, 1, 2로 받는 <code class=\"language-text\">getKey</code>함수가 총 3번 호출되어 세 개의 키를 가져오고 있습니다. 그래서 이전에 0, 1 페이지에 해당하는 내용을 이미 가져왔다면, 해당 데이터는 더 이상 요청하지 않고 새롭게 2 페이지의 내용만 호출해서 이전 데이터에 덧붙여 주는 방식인 것 같습니다. (SWR은 같은 키값을 가진 데이터를 전역으로 공유하며 불필요한 네트워크 요청을 줄여주기 때문입니다.)</p>\n<p>그러니까 그냥 각 페이지의 데이터는 각기 다른 키를 가진 데이터라고 보면 될 것 같습니다! 반환되는 데이터 또한 <code class=\"language-text\">getKey</code>에서 얻어온 key를 가지는 데이터의 배열로 반환되고 있습니다.</p>\n<p>만약 한 페이지의 데이터가</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'John'</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Paul'</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'George'</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<p>위와 같다면, useSWRInfinite로 가져온 데이터는 아래와 같이 각 페이지 별 API 응답의 배열로 제공되고 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token punctuation\">[</span>\n  <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Alice'</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Bob'</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Cathy'</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">...</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">[</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'John'</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'Paul'</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">name</span><span class=\"token operator\">:</span> <span class=\"token string\">'George'</span><span class=\"token punctuation\">,</span> <span class=\"token operator\">...</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n    <span class=\"token operator\">...</span>\n  <span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n  <span class=\"token operator\">...</span>\n<span class=\"token punctuation\">]</span></code></pre></div>\n<h3>적용</h3>\n<p>이제 코드에 적용해보겠습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> getKey <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">pageIndex<span class=\"token punctuation\">,</span> previousPageData</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>previousPageData <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>previousPageData<span class=\"token punctuation\">.</span>length<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span> <span class=\"token keyword\">null</span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// 끝에 도달</span>\n <span class=\"token keyword\">return</span> <span class=\"token template-string\"><span class=\"token template-punctuation string\">`</span><span class=\"token string\">.../page?page=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>pageIndex<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token string\">&amp;size=</span><span class=\"token interpolation\"><span class=\"token interpolation-punctuation punctuation\">${</span>size<span class=\"token interpolation-punctuation punctuation\">}</span></span><span class=\"token template-punctuation string\">`</span></span><span class=\"token punctuation\">;</span> <span class=\"token comment\">// SWR 키</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span><span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>먼저 <code class=\"language-text\">getKey</code>함수를 위와 같이 작성해줬습니다.\n끝에 도달한 경우(이전 페이지가 있긴 있는데, length가 0인 경우, 공식문서를 참고했습니다.)에는 아무런 키를 반환하지 않고, 그렇지 않은 경우에만 매개변수로 전달된 pageIndex에 해당하는 페이지의 내용을 불러오도록 키를 반환하게 했습니다.</p>\n<p>그리고 '더 보기' 와 같은 버튼을 만들어서, 더 보기 버튼에</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">changePage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isLoadingLog <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>isEndPage<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setSize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prev</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> prev <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위와 같은 함수를 핸들러에 등록하여 로딩중이 아니면서, 끝페이지에 도달하지 않은 경우 size를 하나 늘리도록 setSize를 호출해주도록 했습니다.\n물론 끝에 도달한 경우를 <code class=\"language-text\">getKey</code>에서도 한번 거르긴 하지만... 그래도 이렇게 해줬습니다.</p>\n<p>로딩 여부와 끝 페이지에 도달했는지 여부는 다음과 같이 구할 수 있습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>data<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n <span class=\"token comment\">// 로딩 중 여부</span>\n <span class=\"token keyword\">const</span> isLoadingMore <span class=\"token operator\">=</span> isLoading <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>size <span class=\"token operator\">></span> <span class=\"token number\">0</span> <span class=\"token operator\">&amp;&amp;</span> data <span class=\"token operator\">&amp;&amp;</span> <span class=\"token keyword\">typeof</span> data<span class=\"token punctuation\">[</span>size <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span> <span class=\"token operator\">===</span> <span class=\"token string\">'undefined'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token comment\">// 페이지 끝에 도달했는지 여부</span>\n <span class=\"token keyword\">const</span> isReachingEnd <span class=\"token operator\">=</span> data<span class=\"token operator\">?.</span><span class=\"token punctuation\">[</span><span class=\"token number\">0</span><span class=\"token punctuation\">]</span><span class=\"token operator\">?.</span>length <span class=\"token operator\">===</span> <span class=\"token number\">0</span> <span class=\"token operator\">||</span> <span class=\"token punctuation\">(</span>data <span class=\"token operator\">&amp;&amp;</span> data<span class=\"token punctuation\">[</span>data<span class=\"token punctuation\">.</span>length <span class=\"token operator\">-</span> <span class=\"token number\">1</span><span class=\"token punctuation\">]</span><span class=\"token operator\">?.</span>length <span class=\"token operator\">&lt;</span> <span class=\"token constant\">PAGE_SIZE</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token function\">setIsLoadingLog</span><span class=\"token punctuation\">(</span>isLoadingMore<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token function\">setIsEndPage</span><span class=\"token punctuation\">(</span>isReachingEnd<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>data<span class=\"token punctuation\">,</span> size<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>둘 다 공식문서를 참고해서 작성했습니다.</p>\n<p>로딩 중이거나, 데이터가 있긴 있지만, 현재 불러온 페이지 중 마지막 페이지의 데이터가 undefined 경우를 로딩중이라고 보고 있고, 페이지에 끝에 도달했는지 여부는 첫번째 데이터의 길이가 0이거나(아예 첫 페이지부터 데이터가 없는경우) 데이터가 있긴 한데, 제일 마지막에 불러온 데이터의 길이가 한 페이지당 불러오는 데이터의 크기가 작을때를 끝페이지라고 보고 있습니다.</p>\n<p>아무튼 이렇게하니 더 보기 버튼을 클릭했을때 다음 페이지의 데이터가 주르륵 호출되는 것을 확인할 수 있었습니다! 이제 이 이벤트를 스크롤 이벤트에 적용해주기만 하면 됩니다.</p>\n<h3>Intersection Observer API</h3>\n<p>스크롤 이벤트에 적용하려니... 스크롤 이벤트로 무한 스크롤을 구현하면 리플로우에 의해 렌더링 성능이 떨어질 수 있고, 원하는대로 동작하지 않을 수 있다고 합니다. 실제로 스크롤 이벤트로 적용했을 경우 생각대로 동작하지 않아 구글링을 다시 해봤습니다.</p>\n<p>이를 해결하기 위해서는 Intersection Obeserver API를 사용할 수 있습니다! Intersection Observer API는 기본적으로 상위 요소 혹은 최상위 도큐먼트인 뷰포트와 타겟으로 설정한 요소의 교차점을 관찰하여 그 타겟이 뷰포트에 포함되는지 구별하는 기능을 제공하고 있습니다. 쉽게 말해 타켓 요소가, 화면에 노출되어 있는지 여부를 간단하게 구독할 수 있는 API 입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8ab63e8cc26c523a6b0dc213aa70a4ff/e7aec/observer.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 75.36231884057972%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAPCAYAAADkmO9VAAAACXBIWXMAABYlAAAWJQFJUiTwAAABeElEQVR42q1UyU7DMBDl/z8AiUMFP4CExA2JW28cEHABKlrRRZQutEm8jh0/xk7LUtI2CCyN7NieN2/Gb3KAfx4HdZvWemjjYAzP2kEIA6UofVd7Ht6XzQBDCJDsIKSHlIScwbq9AV7Gc0jF4LxXCAuihoC+DMhnC0zmE7xlGlmmsGRbLGWaq7WC0nY3YGQWypJZKJBkBytgXQm3MtowY2zyqQVcH5QMKIRI875BRNsBsyxDr9fDcDhEURSJKYepmK8u5jbguahsZhjQWmbu6gEjoxjR8qXIMIRPhuUK8XoOtJ6Aky5wOQaM1lxHvftRYgqKaxjrYy0l04YAR7gaE1r3hOMHwkWfz4zBdDrFaDRiGekP/1rZCGmTNKJlBUuEX7Tdtzi8IRzdEs47HJADxWzyPP+W+k9hc4qKxRw1V+nOgVjkd68Op48eZx2P9iAKvCrR/k7ZAKw1Fvda2Jsv3RhQfF1HQFc272WTenm7KW5N538B+Je/zTsCU5ihguALpwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"observer\"\n        title=\"\"\n        src=\"/static/8ab63e8cc26c523a6b0dc213aa70a4ff/dd45a/observer.png\"\n        srcset=\"/static/8ab63e8cc26c523a6b0dc213aa70a4ff/948cf/observer.png 138w,\n/static/8ab63e8cc26c523a6b0dc213aa70a4ff/6b2ea/observer.png 275w,\n/static/8ab63e8cc26c523a6b0dc213aa70a4ff/dd45a/observer.png 550w,\n/static/8ab63e8cc26c523a6b0dc213aa70a4ff/d4c13/observer.png 825w,\n/static/8ab63e8cc26c523a6b0dc213aa70a4ff/99f37/observer.png 1100w,\n/static/8ab63e8cc26c523a6b0dc213aa70a4ff/e7aec/observer.png 1726w\"\n        sizes=\"(max-width: 550px) 100vw, 550px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>다음과 같은 경우, target을 관찰하며, target이 Viewport에 포함되는지를 확인할 수 있습니다.</p>\n<p>무한 스크롤을 구현하기 위해서는 가장 맨 밑의 요소가 화면에 노출되어 있는지를 알아내기만 하면 되기 때문에 자세한 내용은 생략하고 해당 부분만 적어보도록 하겠습니다.</p>\n<p>먼저 Intersection Observer API를 사용하는 부분을 커스텀 훅으로 만들었습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">import</span> <span class=\"token punctuation\">{</span> useCallback<span class=\"token punctuation\">,</span> useEffect<span class=\"token punctuation\">,</span> useRef <span class=\"token punctuation\">}</span> <span class=\"token keyword\">from</span> <span class=\"token string\">'react'</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">const</span> <span class=\"token function-variable function\">useIntersect</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">onIntersect</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">const</span> ref <span class=\"token operator\">=</span> <span class=\"token function\">useRef</span><span class=\"token punctuation\">(</span><span class=\"token keyword\">null</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n <span class=\"token keyword\">const</span> callback <span class=\"token operator\">=</span> <span class=\"token function\">useCallback</span><span class=\"token punctuation\">(</span>\n  <span class=\"token punctuation\">(</span><span class=\"token parameter\">entries</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n   entries<span class=\"token punctuation\">.</span><span class=\"token function\">forEach</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">entry</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span>entry<span class=\"token punctuation\">.</span>isIntersecting<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n     <span class=\"token function\">onIntersect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n   <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">[</span>onIntersect<span class=\"token punctuation\">]</span><span class=\"token punctuation\">,</span>\n <span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n <span class=\"token function\">useEffect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>ref<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">)</span> <span class=\"token keyword\">return</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">const</span> observer <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">IntersectionObserver</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  observer<span class=\"token punctuation\">.</span><span class=\"token function\">observe</span><span class=\"token punctuation\">(</span>ref<span class=\"token punctuation\">.</span>current<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token keyword\">return</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> observer<span class=\"token punctuation\">.</span><span class=\"token function\">disconnect</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">[</span>ref<span class=\"token punctuation\">,</span> callback<span class=\"token punctuation\">,</span> onIntersect<span class=\"token punctuation\">]</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n <span class=\"token keyword\">return</span> ref<span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n\n<span class=\"token keyword\">export</span> <span class=\"token keyword\">default</span> useIntersect<span class=\"token punctuation\">;</span></code></pre></div>\n<p>이 커스텀 훅에서는 target요소가 화면에 노출되었을 경우 실행할 함수 onIntersect를 파라미터로 받고, target 요소를 저장하기 위한 ref를 선언하여 리턴하고 있습니다.</p>\n<p>useEffect에서는 IntersectionObserver 객체를 생성하고 observe 호출을 통해 target 요소의 관찰을 시작합니다.</p>\n<p>IntersectionObserver 생성자는</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">new</span> <span class=\"token class-name\">IntersectionObserver</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">new</span> <span class=\"token class-name\">IntersectionObserver</span><span class=\"token punctuation\">(</span>callback<span class=\"token punctuation\">,</span> options<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>위와 같은 형태로 callback과 options 값을 파라미터로 받습니다. options 값은 선택 값으로 몇가지 옵션을 지정할 수 있는데 저는 사용하지 않았습니다.</p>\n<p>여기서 callback은 타겟 요소의 관찰이 시작되거나, 가시성에 변화가 감지되면 실행되는 함수로 entries와 observer를 파라미터로 받습니다. 이 때 entries는 교차 상태가 변화한 target들의 배열이고 observer는 이 콜백 함수를 호출한 IntersectionObserver를 의미합니다.</p>\n<p>저는 root와 target이 교차 상태인지 확인하는 isIntersecting 값이 true이면 onIntersect를 실행하는 함수를 callback으로 작성하여 IntersectionObserver객체를 생성해줬습니다.</p>\n<p>마지막으로 useEffect에서 <code class=\"language-text\">() => observer.disconnect();</code>를 반환함으로써 컴포넌트가 언마운트될 때 cleanup을 통해 disconnect를 호출하여 모든 요소의 관찰을 중지하도록 했습니다.</p>\n<p>요약하자면 target요소가 화면에 노출되는 순간 onIntersect가 호출되는 커스텀훅을 만든것입니다.</p>\n<p>이 훅은 다음과 같이 사용하였습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">changePage</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n <span class=\"token keyword\">if</span> <span class=\"token punctuation\">(</span><span class=\"token operator\">!</span>isLoadingLog <span class=\"token operator\">&amp;&amp;</span> <span class=\"token operator\">!</span>isEndPage<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n  <span class=\"token function\">setSize</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">prev</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> prev <span class=\"token operator\">+</span> <span class=\"token number\">1</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n <span class=\"token punctuation\">}</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> bottomRef <span class=\"token operator\">=</span> <span class=\"token function\">useIntersect</span><span class=\"token punctuation\">(</span>changePage<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>이렇게 다음 페이지를 호출할 수 있도록 하는 함수를 onIntersect로 전달하여 bottomRef가 화면에 노출될 경우 다음 페이지를 불러올 수 있도록 해줬고,</p>\n<div class=\"gatsby-highlight\" data-language=\"js\"><pre class=\"language-js\"><code class=\"language-js\"><span class=\"token operator\">&lt;</span>LogWrapper<span class=\"token operator\">></span>\n <span class=\"token punctuation\">{</span>pointLogs<span class=\"token punctuation\">.</span><span class=\"token function\">flat</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">.</span><span class=\"token function\">map</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">log</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">(</span>\n  <span class=\"token operator\">&lt;</span>Log key<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>log<span class=\"token punctuation\">.</span>id<span class=\"token punctuation\">}</span><span class=\"token operator\">></span><span class=\"token operator\">...</span><span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>Log<span class=\"token operator\">></span>\n <span class=\"token punctuation\">)</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">}</span>\n <span class=\"token operator\">&lt;</span>Log ref<span class=\"token operator\">=</span><span class=\"token punctuation\">{</span>bottomRef<span class=\"token punctuation\">}</span> <span class=\"token operator\">/</span><span class=\"token operator\">></span>\n<span class=\"token operator\">&lt;</span><span class=\"token operator\">/</span>LogWrapper<span class=\"token operator\">></span></code></pre></div>\n<p>bottomRef는 스크롤 맨 아래 위치하는 요소에 붙여주는 방식으로 사용을 했습니다.</p>\n<h3>revalidateFirstPage</h3>\n<p>오호 이렇게 하니 스크롤 했을때 페이지 별로 요청이 잘 가고 있습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 372px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/77875ec3ef4c3e104bc0f42e04f1788f/98b6e/page0.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 71.01449275362319%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAOCAYAAAAvxDzwAAAACXBIWXMAAAsTAAALEwEAmpwYAAABe0lEQVR42qWTW0/CQBCF+09EoIAaW6wQFGy39wtF4v+RRGiRAoGE6+89zq5vEFoSHk52ns5+M2dG6r4+YTz+wWq1wmKxwHK5FOL1er3G92gE0/FgMAu266OnG1CaTdyXy6hUq2eS9I6C+TzD4XDAdrvFbrcT4vXxeEQ6nSKMP+H4Ib1DWGSqtduo1mqoNRpnkrraI7LZDPv9HpvNRhhx8Zp/MklSOF4I03bhkqnOTChqE6VSCWWiPJVkdFRk2WXDJE3hRzFsz0cQD2C6HrRWDmHvCkLbC8BsB14QQTcKCPUCQtEytWpRMC4ZGpaNl1brlhkmZOZDNy0xS5GyquYRKoWEnIyvDJ8ls5z8Gb5rD0T4e9lwkoh2dcYJA3SJ8JkI74iQ7+KprkrZC/u03K54Ga0PJ5SJsE5Ep7pqhrxdw7QF4Qdjt6XMCYP+QMwx4pfiFOxhIeHkn5CH4fhEqJt4VnJSZm/5KYtbHgzhRX3Ewy+x5PyWK7IMuV4/0x9NxzJF7v+8gQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"page0\"\n        title=\"\"\n        src=\"/static/77875ec3ef4c3e104bc0f42e04f1788f/98b6e/page0.png\"\n        srcset=\"/static/77875ec3ef4c3e104bc0f42e04f1788f/948cf/page0.png 138w,\n/static/77875ec3ef4c3e104bc0f42e04f1788f/6b2ea/page0.png 275w,\n/static/77875ec3ef4c3e104bc0f42e04f1788f/98b6e/page0.png 372w\"\n        sizes=\"(max-width: 372px) 100vw, 372px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>어라? 그런데 이렇게 중간 중간 0번 페이지의 요청이 끼어서 가고 있습니다.</p>\n<p>왜 이러는지 좀 찾아보니 <br/>\n<a href=\"https://github.com/vercel/swr/issues/1638\">https://github.com/vercel/swr/issues/1638</a> <br/>\n오호 버그가 아니라 기능이라네요?</p>\n<p>위의 useSWRInfinite 설명에도 나와있었듯 <br/>\n<code class=\"language-text\">revalidateFirstPage = true: always try to revalidate the first page</code><br/>\n이 옵션을 <code class=\"language-text\">useSWRInfinite(getKey, fetcher, { revalidateFirstPage: false })</code> 이런식으로 false로 주면 해결이 됩니다! 저게 옵션 이름 그대로 첫 페이지를 revalidate하는 옵션인데 기본값이 true였기 때문에 ... 저런 현상이 있었습니다. 옵션은 후루룩 읽고 넘어간 부분이라 몰랐네요</p>\n<p>아무튼 이렇게 하니 페이지 별로 호출이 잘 되고있는 것을 확인할 수 있었습니다!</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 431px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/5a28d298e90dc01bb29e11bbfefbd592/9cb4e/page.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 34.05797101449276%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAYAAAAIy204AAAACXBIWXMAAAsTAAALEwEAmpwYAAABM0lEQVR42nWRy3KCQBRE+RVg0EUANVuVp2g0X5FFUshD8w9QRVz5BPRrO3duspBKXJyqW9PQ031Hid/f8LXboSgKlGXJyLmqKnzEa/jhHPPlK2aLJYajZxiGgV6/30HQmT+LWFc+8wTX2w2n0wnn85mR87VtkeY5xo5HH88xdT08WRY0XYcuRAd5Np66rCubLEZdN9jv9zgcDoycL5cLkjTDxPXZ0PECmIMBdEojer0OuiEwcVzWlW2+RtO0bHQ8Hhk513WNJMspmY8wWsD1A9j0g6BEsvY9ghI6Lum2NMzIsP1r2DQ11klKN3sIfyubtv2gskZNSLdsucPHCbPNFl4YIXpZIaCU9nDEFQ16iHvkGhw/ZF3ZpPG/CaVhSpXl7n4qh7x0VdM45T2qpmIiH8W08A09WhMm3abEBwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"page\"\n        title=\"\"\n        src=\"/static/5a28d298e90dc01bb29e11bbfefbd592/9cb4e/page.png\"\n        srcset=\"/static/5a28d298e90dc01bb29e11bbfefbd592/948cf/page.png 138w,\n/static/5a28d298e90dc01bb29e11bbfefbd592/6b2ea/page.png 275w,\n/static/5a28d298e90dc01bb29e11bbfefbd592/9cb4e/page.png 431w\"\n        sizes=\"(max-width: 431px) 100vw, 431px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>무한 스크롤 ... swr을 사용하니 생각보다는 간단했지만 스크롤 이벤트에 적용하는 과정이 꽤나 어려웠던 것 같습니다. 정리하고보니 그렇게 복잡한 내용은 없는 것 같지만 생각보다 많이 해맨 부분이라 기록해두고 싶었습니다 읽어주셔서 감사합니다~!</p>\n<p><br/><br/></p>\n<hr/>\n<p><strong>Reference</strong> <br/>\n<a href=\"https://swr.vercel.app/ko/docs/pagination#useswrinfinite\">https://swr.vercel.app/ko/docs/pagination#useswrinfinite</a> <br/>\n<a href=\"https://tech.kakaoenterprise.com/149\">https://tech.kakaoenterprise.com/149</a></p>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%AC%B4%ED%95%9C-%EC%8A%A4%ED%81%AC%EB%A1%A4-\">무한 스크롤 ?</a></p>\n</li>\n<li>\n<p><a href=\"#useswrinfinite\">useSWRInfinite</a></p>\n<ul>\n<li><a href=\"#%EC%82%AC%EC%9A%A9-%EB%B0%A9%EB%B2%95\">사용 방법</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EC%A0%81%EC%9A%A9\">적용</a></p>\n</li>\n<li>\n<p><a href=\"#intersection-observer-api\">Intersection Observer API</a></p>\n</li>\n<li>\n<p><a href=\"#revalidatefirstpage\">revalidateFirstPage</a></p>\n</li>\n</ul>","frontmatter":{"title":"날백수인 내가 SWR로 무한 스크롤(Infinite scroll)을 구현한 방법","date":"November 26, 2023","description":"무한 스크롤(Infinite scroll)을 구현해봤습니다.","category":"프로젝트","icon":"🎢"}},"previous":{"fields":{"slug":"/swr/"},"frontmatter":{"title":"SWR 사용해보기"}},"next":null},"pageContext":{"id":"e066ddcc-cf25-5691-afbb-d2a3cec1b88c","previousPostId":"44a4ab89-ff59-57d5-a414-aed307e86eda","nextPostId":null}},"staticQueryHashes":["2841359383"],"slicesMap":{}}