{"componentChunkName":"component---src-pages-blog-post-js","path":"/memoization-api/","result":{"data":{"site":{"siteMetadata":{"title":"klloo"}},"markdownRemark":{"id":"1c8caf3c-380e-518f-b680-e79b1a7068d4","excerpt":"문제 상황 지난번에 로그인을 이렇게 구현을 했는데요 \n요약하자면 요청마다 헤더에 엑세스 토큰을 넣어서 보내주고, 토큰이 만료되어 40…","html":"<h3>문제 상황</h3>\n<p>지난번에 로그인을 <a href=\"https://klloo.github.io/react-login-jwt/\">이렇게</a> 구현을 했는데요 <br/>\n요약하자면 요청마다 헤더에 엑세스 토큰을 넣어서 보내주고, 토큰이 만료되어 401에러가 발생하면 토큰 재발급을 요청하여 새로 받은 토큰으로 다시 요청을 보내는 방식으로 구현을 했습니다.</p>\n<p>그런데 이렇게 구현을 하니... 한 페이지에서 동시에 여러 요청을 보냈는데 토큰이 만료됐을 경우 그 여러 요청만큼 재요청이 갑니다. <br/></p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/6fc187dcaf47a0c1e15a7fa90e6ce75a/fe720/before.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 28.985507246376812%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAABYlAAAWJQFJUiTwAAABIklEQVR42jVQ2W7DMAzLn6w5XCBpDsfxlaNoVxQbumJ93/9/CEd5y4NgSRZFUtnntiGEyAjwzsF7n/I5RmzLgqpSMMMApY4Y+x6PywWmH1CyX/33vDGpXonPtnHEwmS2FpPWqOs6RdM00BwuyhJD1xFQQfP9vr1jIkHOvvS604kEfao98dmHs6gJVoqMHJAF8lmxjtOEslRJgSi1JP95PhFY5wUXlhWsHpMyqW/rimz1DmaybBSJUYAiXyx6H1JvIHNSQyX3+x2ntv0jJmaiMzmT5DHOyJbg4QiUAVm2hzoeYcksuaaK/X18PdHKCahOwtCFcx4FFQbePbuuM2Ye/5DnaekeYlkGJDe0KK+m5dfrhbbtkiLBOKqLnHs7HLCdz/gF7QK33GlJCdgAAAAASUVORK5CYII='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"before\"\n        title=\"\"\n        src=\"/static/6fc187dcaf47a0c1e15a7fa90e6ce75a/dd45a/before.png\"\n        srcset=\"/static/6fc187dcaf47a0c1e15a7fa90e6ce75a/948cf/before.png 138w,\n/static/6fc187dcaf47a0c1e15a7fa90e6ce75a/6b2ea/before.png 275w,\n/static/6fc187dcaf47a0c1e15a7fa90e6ce75a/dd45a/before.png 550w,\n/static/6fc187dcaf47a0c1e15a7fa90e6ce75a/d4c13/before.png 825w,\n/static/6fc187dcaf47a0c1e15a7fa90e6ce75a/99f37/before.png 1100w,\n/static/6fc187dcaf47a0c1e15a7fa90e6ce75a/fe720/before.png 1448w\"\n        sizes=\"(max-width: 550px) 100vw, 550px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>바로 이렇게... 이렇게 되면 불필요한 네트워크 요청이 많아지게 됩니다. 그래서 이 부분을 개선해보려고 합니다.</p>\n<h3>해결</h3>\n<p>저는 <a href=\"https://gusrb3164.github.io/web/2022/08/07/refresh-with-axios-for-client/\">이 포스팅</a>을 보고 memoization을 사용하여 이 문제를 해결했습니다. <br/>\n먼저 처음 요청된 재발급 요청을 메모이제이션 하게 되면, 이후 메모이제이션된 시간동안은 동일한 요청들을 재사용하게 되어 중복된 요청이 더 이상 호출되지 않게 됩니다.</p>\n<p>코드는 간단합니다</p>\n<div class=\"gatsby-highlight\" data-language=\"ts\"><pre class=\"language-ts\"><code class=\"language-ts\"><span class=\"token keyword\">import</span> pMemoize <span class=\"token keyword\">from</span> <span class=\"token string\">'p-memoize'</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">import</span> ExpiryMap <span class=\"token keyword\">from</span> <span class=\"token string\">'expiry-map'</span><span class=\"token punctuation\">;</span>\n\n\n<span class=\"token comment\">// access token 재발급</span>\n<span class=\"token keyword\">const</span> cache <span class=\"token operator\">=</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">ExpiryMap</span><span class=\"token punctuation\">(</span><span class=\"token number\">2000</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token keyword\">const</span> getRefreshToken <span class=\"token operator\">=</span> <span class=\"token function\">pMemoize</span><span class=\"token punctuation\">(</span>\n  <span class=\"token keyword\">async</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token operator\">:</span> <span class=\"token builtin\">Promise</span><span class=\"token operator\">&lt;</span><span class=\"token builtin\">string</span> <span class=\"token operator\">|</span> <span class=\"token keyword\">void</span><span class=\"token operator\">></span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token keyword\">const</span> res <span class=\"token operator\">=</span> <span class=\"token keyword\">await</span> <span class=\"token function\">refresh</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">const</span> accessToken <span class=\"token operator\">=</span> res<span class=\"token punctuation\">.</span>data<span class=\"token punctuation\">.</span>data<span class=\"token operator\">?.</span>accessToken<span class=\"token punctuation\">;</span>\n      <span class=\"token keyword\">return</span> accessToken<span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n      <span class=\"token comment\">// 로그아웃 처리</span>\n      <span class=\"token function\">logout</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n    <span class=\"token punctuation\">}</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n  <span class=\"token punctuation\">{</span> cache <span class=\"token punctuation\">}</span><span class=\"token punctuation\">,</span>\n<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p><a href=\"https://github.com/sindresorhus/p-memoize\">p-memoize</a>라는 라이브러리를 사용하여 토큰 재발급 함수를 감싸줬습니다. 이렇게 하면 해당 함수는 메모이제이션 됩니다. <code class=\"language-text\">expiry-map</code>을 사용하면 캐시된 함수의 만료시간을 정할 수 있다고 합니다. 저는 2초로 설정을 해줬습니다.</p>\n<p>제가 참고한 블로그에서는 <a href=\"https://www.npmjs.com/package/mem\">mem 라이브러리</a>를 사용하고 있었지만 해당 라이브러리는 deprecated되었다고 하며... memoize라는 라이브러리로 이름이 바뀌었다고 하더라구요? 근데 거기에 들어가보니까 또 promise를 반환해서 사용할꺼면 p-memoize를 사용하라고 하더라구요? 그래서 p-memoize를 설치하고 사용해줬습니다!</p>\n<p>다시 실행시켜보면 중복 요청 문제가 해결된 것을 확인할 수 있습니다!</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/ce984ff0f55ebeaa4e758214795175f9/0d390/after.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 23.18840579710145%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAFCAYAAABFA8wzAAAACXBIWXMAABYlAAAWJQFJUiTwAAAA7UlEQVR42j1QW5KDMAzjKA0QyjsJCYHttvSTE7T3v4lW9s7w4bEka2QnRZodTG1RN3fYe4uGZYmHfkD0QXXpogXncb7fFxfvNE7Y06o8LxHFkSIW7xGdQ9e2KKtKqyUO8wxDLDPRFvbPeSKHoHpV11zcYY9R54k5xSN4pjcaZm1Dk+WwRt/13LjgVlbY2EWLvFADyQ15Se88jji2TX3PNaPITDXcJEG1lLW6WS50vFCwm6arn8cBN/5z8Q59j8SLhXv6i9/HD/+pgSnL67mC245P2XfcjEFaV9VCWPD9fLHmrLpoE0Oer5fyvG34A/J1lxXu2ggBAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"after\"\n        title=\"\"\n        src=\"/static/ce984ff0f55ebeaa4e758214795175f9/dd45a/after.png\"\n        srcset=\"/static/ce984ff0f55ebeaa4e758214795175f9/948cf/after.png 138w,\n/static/ce984ff0f55ebeaa4e758214795175f9/6b2ea/after.png 275w,\n/static/ce984ff0f55ebeaa4e758214795175f9/dd45a/after.png 550w,\n/static/ce984ff0f55ebeaa4e758214795175f9/d4c13/after.png 825w,\n/static/ce984ff0f55ebeaa4e758214795175f9/99f37/after.png 1100w,\n/static/ce984ff0f55ebeaa4e758214795175f9/0d390/after.png 1472w\"\n        sizes=\"(max-width: 550px) 100vw, 550px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>","tableOfContents":"<ul>\n<li><a href=\"#%EB%AC%B8%EC%A0%9C-%EC%83%81%ED%99%A9\">문제 상황</a></li>\n<li><a href=\"#%ED%95%B4%EA%B2%B0\">해결</a></li>\n</ul>","frontmatter":{"title":"API 중복호출 해결하기","date":"January 10, 2024","description":"memoization을 활용하여 API 중복호출 해결하기","category":"FE","icon":"👥","tags":["Frontend","React","JavaScript"]}},"previous":{"fields":{"slug":"/react-login-jwt/"},"frontmatter":{"title":"리액트에서 jwt 기반 로그인 구현하기"}},"next":{"fields":{"slug":"/blog-tag/"},"frontmatter":{"title":"Gatsby 블로그에 태그 만들기"}}},"pageContext":{"id":"1c8caf3c-380e-518f-b680-e79b1a7068d4","previousPostId":"7cef6f34-6666-5d78-8f66-298d12a847c7","nextPostId":"2a339a1d-b643-5aa8-b8fe-35614a8243e9"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}