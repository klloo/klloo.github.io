{"componentChunkName":"component---src-pages-blog-post-js","path":"/deploy/","result":{"data":{"site":{"siteMetadata":{"title":"klloo"}},"markdownRemark":{"id":"4d9d8f78-9ab5-528a-8fbf-892acff26925","excerpt":"최근 제가 참여하고 있는 알고리즘 스터디를 위한 내부 사이트를 제작하는 프로젝트를 진행하고 있었는데요. 어느정도 형태가 갖추어지면서 이제 사용해도 좋겠다! 싶어 일단 배포를 해두기로 했습니다 전체적인 구조  전체적인 구조는 위와 같습니다.\n먼저 AWS의 EC2와 RDS…","html":"<p>최근 제가 참여하고 있는 알고리즘 스터디를 위한 내부 사이트를 제작하는 프로젝트를 진행하고 있었는데요. 어느정도 형태가 갖추어지면서 이제 사용해도 좋겠다! 싶어 일단 배포를 해두기로 했습니다</p>\n<h2>전체적인 구조</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/3efdfd7a8f6f0f8275dd63d5ab91acf5/5a6dd/structure.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 55.79710144927537%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAALCAYAAAB/Ca1DAAAACXBIWXMAAAsTAAALEwEAmpwYAAABeklEQVR42o1Sy27CMBDMl/dveuPWD+ipUoW4UKQeWlSkFlAeBNvBxolf07VRIkihwtLKyXp3dnZ3Mlw7wZOF4VeZgJ0MMA7wYRQaLh0Z/jl9qNABP8yjEhpSGzjnbuZko3LpkssZzO47AQbvE3RkIgSHlAe0bZviPNGtm/a8mRPgQJvu+FVPn2DXC/jkc6ilxXxroNUR1joCSi/YC4mHxyk0zSJ4l3D+tkwPG2GwKFyapXcWedPhdc1gvIKxhpiKwZhooFsNY+wJMFZbLpdQSkFrje6oaF5HzAuaVyOQ5wX5JT52L/jav0O1CozxBHZoGnClwVkB0+nUXWatxWQyQVmW4Jyj4Q3WbE2AczgTGRpUxPAtp5aIraeFxJyYHRnFBUXrx5CNV++dB5MMpaxSgboqsdpxPK82sBRWWA/bdQlgLJkLwN5i9XFgcSgw206xl0d87gW11yLcJZskBWJArUXr2+lMR8sgH92WJGPv1uGZ+q/ZIPYQbgL+AjGYW6WgXw4JAAAAAElFTkSuQmCC'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"structure\"\n        title=\"\"\n        src=\"/static/3efdfd7a8f6f0f8275dd63d5ab91acf5/dd45a/structure.png\"\n        srcset=\"/static/3efdfd7a8f6f0f8275dd63d5ab91acf5/948cf/structure.png 138w,\n/static/3efdfd7a8f6f0f8275dd63d5ab91acf5/6b2ea/structure.png 275w,\n/static/3efdfd7a8f6f0f8275dd63d5ab91acf5/dd45a/structure.png 550w,\n/static/3efdfd7a8f6f0f8275dd63d5ab91acf5/5a6dd/structure.png 802w\"\n        sizes=\"(max-width: 550px) 100vw, 550px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>전체적인 구조는 위와 같습니다.\n먼저 AWS의 EC2와 RDS를 생성하였고 spring boot 코드에서 데이터베이스를 RDS와 연동해두었습니다. 그리고 EC2 내부에서는 도커를 사용해서 총 3개의 컨테이너를 띄웠습니다.</p>\n<ol>\n<li>Reverse Proxy 서버로 사용할 Nginx</li>\n<li>Spring boot</li>\n<li>Web Server로 사용할 Nginx (빌드된 React 파일이 마운트 되어 있음)</li>\n</ol>\n<p>외부에서 443으로 요청이 오면 Reverse Proxy 서버인 Nginx가 먼저 요청을 받고, /api로 시작하는 요청이라면 8080포트로, 그냥 /로 시작하는 요청이라면 3000 포트로 요청을 전달해주게 됩니다.</p>\n<p>여기서 <strong>리버스 프록시</strong>란 클라이언트와 웹 서버 사이에 위치하여 클라이언트 요청을 서버로 전달하고, 서버에서 받은 응답을 클라이언트에게 전달하는 중간 서버 역할을 하는 서버를 말합니다.\n리버스 프록시를 사용하면 로드 밸런싱, 무중단 배포 등 여러 방면에서 이점이 있습니다.</p>\n<p>하지만 제가 배포하려는 서비스는 규모가 큰 서비스가 아니었기 때문에 이런 부분들은 큰 고려 사항이 아니었고, CORS 설정을 간단하게 처리할 수 있다는 점 때문에 이런 구조를 선택하게 되었습니다. (Nginx 설정 중 proxy_pass를 통해 CORS를 쉽게 해결할 수 있습니다.)</p>\n<p>도커 이미지를 띄우는 과정은 아래와 같이 진행했습니다.</p>\n<ol>\n<li>로컬에서 Frontend 이미지 빌드</li>\n<li>로컬에서 Backend 이미지 빌드</li>\n<li>Docker hub에 빌드한 이미지 push</li>\n<li>EC2 내부에서 해당 이미지 pull</li>\n<li>docker-compose를 사용해 Nginx 이미지와 pull받은 두 이미지를 동시에 실행</li>\n</ol>\n<p>도커를 사용한 이유는 배포가 편리하기 때문..!이었습니다. 아직 인프라와 관련된 지식이 부족한 편인데.. 일단 배포 환경을 신경 쓸 필요가 없었고 수정 사항이 생기더라도 새로 빌드한 이미지만 갈아끼우면 되기 때문에 이런 방식들이 깔끔하고 마음에 들어서 사용을 했습니다!</p>\n<h2>배포 과정</h2>\n<p>위에서 간략하게 설명한 배포 과정을 자세히 살펴보겠습니다.</p>\n<h3>도메인 구입 및 연동</h3>\n<p>도메인은 <a href=\"https://domain.gabia.com/\">가비아</a>에서 구매를 했습니다. 1년치를 구매했고요 ...\n여러 도메인을 검색해보며 가격을 비교하는게 꽤나 재밌었습니다.</p>\n<p>그리고 <a href=\"https://developer-ping9.tistory.com/320\">이 블로그</a>를 참고하여 EC2와 도메인을 연결했습니다.</p>\n<h3>도커 파일 작성</h3>\n<p>로컬에서 frontend쪽 이미지와 backend쪽 이미지를 빌드하기 위한 도커 파일을 작성해뒀습니다.</p>\n<h4>frontend</h4>\n<deckgo-highlight-code language=\"dockerfile\"  >\n          <code slot=\"code\">FROM node:alpine as builder\nWORKDIR /usr/src/app\nCOPY package.json .\nRUN yarn install\nCOPY ./ ./\nRUN yarn build\n\nFROM nginx\nEXPOSE 3000\nCOPY ./nginx.conf /etc/nginx/conf.d/default.conf\nCOPY --from=builder usr/src/app/build  /usr/share/nginx/html</code>\n        </deckgo-highlight-code>\n<p>이 도커파일을 해석해 보자면 ...</p>\n<p>먼저 node 이미지를 기반으로 React 코드를 빌드합니다.\npackage.json 파일을 컨테이너의 작업 디렉토리로 복사하여 yarn install을 통해 필요한 종속성을 설치하고, 현재 디렉토리의 파일 전체를 컨테이너의 작업 디렉토리로 복사하여 yarn build 명령어를 통해 React 코드를 빌드합니다.</p>\n<p>그리고 nginx 이미지를 기반으로 웹서버를 구성합니다.\n먼저 컨테이너 외부로 3000 포트를 열고 현재 디렉토리에 작성해둔 nginx 설정파일을 컨테이너 내부의 nginx 설정파일로 복사해줍니다.\n그리고 이전 builder 단계에서 빌드한 파일을 nginx의 기본 웹 루트 디렉토리로 복사합니다.</p>\n<p>작성한 nginx 설정 파일은 아래와 같습니다.</p>\n<h4>nginx.conf</h4>\n<deckgo-highlight-code   >\n          <code slot=\"code\">server {\n    listen 3000;\n\n    location / {\n        root /usr/share/nginx/html;\n        index index.html index.htm;\n        try_files $uri  $uri/ /index.html;\n    }\n    underscores_in_headers on;\n}</code>\n        </deckgo-highlight-code>\n<p>먼저 3000 포트로 요청을 받기로 합니다.\n그리고 '/'으로 들어오는 모든 요청에 대해 nginx 기본 웹 루트 디렉토리에서 정적 파일들을 제공하도록 했습니다.</p>\n<p><code class=\"language-text\">underscores_in_headers on</code>은 http요청 헤더에서 underscore(_)를 허용하도록하는 옵션입니다. nginx는 기본적으로 헤더에 underscore가 포함되어 있다면 해당 헤더를 자동으로 버려버린다고 합니다... 저희 프로젝트에서는 인증 시 사용하는 토큰을 요청 헤더에서 주고 받을 때 해당 헤더 이름에 _가 들어가는데 이 설정을 해주지 않은 바람에 조금 많이 애를 먹었었습니다...</p>\n<p>아무튼 이렇게하면 리액트 코드를 빌드한 결과물인 정적 파일을 서브할 수 있는 웹서버를 구성할 수 있습니다.</p>\n<h4>backend</h4>\n<deckgo-highlight-code language=\"dockerfile\"  >\n          <code slot=\"code\">FROM openjdk:11\nARG JAR_FILE=build/libs/*.jar\nCOPY ${JAR_FILE} app.jar\nENTRYPOINT [&quot;java&quot;,&quot;-jar&quot;,&quot;/app.jar&quot;]</code>\n        </deckgo-highlight-code>\n<p>먼저 jdk 11 이미지를 기반으로 합니다. 이 이미지에는 Java 11이 설치되어 있습니다.\n그리고 빌드된 jar파일을 컨테이너 내부 app.jar라는 이름으로 복사를 해둡니다.\nENTRYPOINT는 컨테이너가 시작될 때 실행되는 명령을 지정할 수 있는데 여기서는 java -jar /app.jar 명령을 지정하여 컨테이너 실행 시 내부에서 JAR파일을 실행하도록 했습니다.</p>\n<h3>SSL 인증서 발급</h3>\n<p>EC2 내부에서 certbot을 이용해 SSL 인증서를 발급받았습니다.</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">apt-get install python3-certbot-nginx\ncertbot certonly --nginx -d &lt;도메인 주소&gt;</code>\n        </deckgo-highlight-code>\n<p>이 인증서의 만료기한은 90일이라 .. 90일마다 갱신을 해줘야 합니다. crontab을 사용하면 자동으로 인증서를 갱신하도록 설정해줄 수 있습니다.</p>\n<h3>docker-compose.yml 파일 생성</h3>\n<p>EC2내부에서 도커 이미지를 동시에 띄우기 위해 docker-compose.yml파일을 작성해야 합니다.</p>\n<deckgo-highlight-code language=\"yml\"  >\n          <code slot=\"code\">version: &#39;1&#39;\nservices:\n backend:\n  container_name: springboot-app\n  image: backend-image\n  expose:\n   - 8080\n\n frontend:\n  container_name: react-app\n  image: frontend-image\n  expose:\n   - 3000\n\n nginx:\n  container_name: nginx\n  image: nginx:latest\n  restart: always\n  volumes:\n   - ./conf/:/etc/nginx/conf.d\n   - /var/log/nginx:/var/log/nginx\n   - /etc/letsencrypt:/etc/letsencrypt\n  ports:\n   - 80:80\n   - 443:443\n  depends_on:\n   - backend\n   - frontend</code>\n        </deckgo-highlight-code>\n<p>backend, frontend, nginx 총 3개의 서비스를 정의하고 각 서비스가 실행되는 방식 및 설정을 지정한 파일입니다.</p>\n<h4>backend</h4>\n<p>'springboot-app'이라는 이름으로 컨테이너를 띄웁니다.\n이 서비스는 docker hub에서 backend-image라는 이미지를 가져와서 실행 시키고 컨테이너를 8080포트로 노출합니다.</p>\n<h4>frontend</h4>\n<p>'react-app'이라는 이름으로 컨테이너를 띄웁니다.\n이 서비스는 docker hub에서 frontend-image라는 이미지를 가져와서 실행 시키고 컨테이너를 3000포트로 노출합니다.</p>\n<h4>nginx</h4>\n<p>'react-app'이라는 이름으로 컨테이너를 띄웁니다.\n이 서비스는 nginx 이미지로 실행을 시키는데 호스트 시스템의 디렉토리를 컨테이너 내부 디렉토리와 공유하여 nginx 설정, 로그 및 SSL 인증서를 관리합니다.\n또 호스트의 80번 포트와 443번 포트를 컨테이너의 80번 포트와 443번 포트로 연결합니다.</p>\n<p>./conf 경로에 있는 설정 파일들을 nginx설정에 사용하도록 하였는데 해당 설정파일은 아래와 같습니다.</p>\n<p><strong>nginx.conf</strong></p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">server {\n       listen 80;\n       server_name randps.kr;\n       underscores_in_headers on;\n       return 301 https://randps.kr$request_uri;   # http로 들어오면 https로 redirect 해주는 부분\n}\n\nserver {\n       listen 443 ssl;\n\n       server_name randps.kr;\n\n       ssl_certificate /etc/letsencrypt/live/randps.kr/fullchain.pem;\n       ssl_certificate_key /etc/letsencrypt/live/randps.kr/privkey.pem;\n\n       location /api {\n\t       proxy_pass http://springboot-app:8080;\n\t       proxy_set_header Host $host;\n               proxy_set_header X-Real-IP $remote_addr;\n               proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n               proxy_set_header X-Forwarded-Proto $scheme;\n               }\n       location / {\n               proxy_pass http://react-app:3000;\n               proxy_set_header Host $host;\n               proxy_set_header X-Real-IP $remote_addr;\n               proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;\n               proxy_set_header X-Forwarded-Proto $scheme;\n       }\n       underscores_in_headers on;\n\n}</code>\n        </deckgo-highlight-code>\n<p>이 설정파일은 nginx를 사용하여 HTTPS로 보안된 연결을 설정하고 백엔드 API와 웹 애플리케이션을 프록시하는 간단한 리버스 프록시 구성을 나타냅니다.</p>\n<p>먼저 80포트로 HTTP요청을 받는다면 HTTPS로 리다이렉션 합니다.</p>\n<p>그리고 443 포트로 HTTPS 요청을 받으며 SSL을 사용합니다. ssl_certificate 및 ssl_certificate_key는 SSL 인증서와 개인 키 파일의 경로를 지정합니다.</p>\n<p>Let's Encrypt를 사용하므로 etc/letsencrypt/live/randps.kr/fullchain.pem 및 /etc/letsencrypt/live/randps.kr/privkey.pem 경로에 인증서와 키 파일이 있어야 합니다.</p>\n<p>또 /api 경로로 들어오는 요청을 백엔드 서버로 프록시 하고 springboot-app컨테이너의 8080포트로 요청을 전달하도록 했습니다. 그 외의 /로 들어오는 모든 요청은 웹 서버로 프록시 하여 react-app 컨테이너의 3000포트로 요청을 전달하게 됩니다.</p>\n<h3>배포</h3>\n<p>배포를 위한 준비는 다 되었습니다. 이제 도커 이미지를 빌드하고 EC2에서 해당 이미지를 내려받아 실행시켜주기만 하면됩니다.</p>\n<p>먼저 frontend와 backend 이미지를 각각 빌드하여 Docker hub에 올려줍니다.</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">docker build --platform linux/amd64 -t &lt;image 이름&gt; . // 이미지 빌드\ndocker push &lt;image 이름&gt; // 이미지 푸시</code>\n        </deckgo-highlight-code>\n<p>저는 M1 맥북을 사용하고 있는데, 이미지를 그냥 빌드하게 되면 도커가 해당 이미지를 빌드할때 생성된 빌드 플랫폼이 EC2서버와 M1 맥북간의 호환성이 안맞아 문제가 발생합니다. 그래서 이를 linux/amd64 플랫폼 형태로 빌드하기 위해 <code class=\"language-text\">--platform linux/amd64</code> 옵션을 적어주었습니다.</p>\n<p>그리고 EC2에서는 두 이미지를 pull 받아줍니다. (도커가 설치되어 있어야하고, 도커 허브에 로그인 되어있어야 합니다.)</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">sudo docker pull &lt;backend image 이름&gt;\nsudo docker pull &lt;frontend image 이름&gt;</code>\n        </deckgo-highlight-code>\n<p>그리고 docker-compose 명령어를 통해 이미지를 모두 실행시켜주면 배포가 완료됩니다!</p>\n<deckgo-highlight-code   >\n          <code slot=\"code\">sudo docker-compose up -d // -d 옵션은 컨테이너를 백그라운드에서 실행시키는 옵션</code>\n        </deckgo-highlight-code>\n<h2>배포 자동화</h2>\n<p>docker를 사용하여 비교적 간단하게 배포를 진행할 수는 있지만 이 작업마저도 귀찮은 부분이 있습니다.. 수정 사항이 발생하면 매번 이미지를 새로 빌드하고, EC2에 접속하여 새 이미지를 pull받은 다음 다시 실행시켜줘야 합니다.</p>\n<p>그래서 이 부분을 자동화 시켜보기로 했습니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a414becd4834606010acd1c8ac1941e9/f0551/cicd.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 31.15942028985507%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAGCAYAAADDl76dAAAACXBIWXMAAAsTAAALEwEAmpwYAAAA4klEQVR42n1R22rDMAzN/3/O/mIPexlbWMogzQJL19HFdnxLfDmV7A5GaXdAWOhyjiQ3MUZs2wYG+yGE4ueMm7iO56tA8zVNaF+eYZ1D275i13Xw5Ctt8alAYgHGGEgpy5tvKVEsp1QJuSClWqSUKo0MnvQkFjjvywZa62KjyJhtxhqBhepPSkN0j9BPD5Xw+3jA++6N1C0+hgHjOMI5i8U4TDJiJTJPpNVWKA/4LSOkeqJIk1klYH6OlXCeBSZamzHs9+j7vk4YE6RDaUgXuwfe8vcQzd8EN7Hqf7j3WbhQngHCktSY/F+9fwAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cicd\"\n        title=\"\"\n        src=\"/static/a414becd4834606010acd1c8ac1941e9/dd45a/cicd.png\"\n        srcset=\"/static/a414becd4834606010acd1c8ac1941e9/948cf/cicd.png 138w,\n/static/a414becd4834606010acd1c8ac1941e9/6b2ea/cicd.png 275w,\n/static/a414becd4834606010acd1c8ac1941e9/dd45a/cicd.png 550w,\n/static/a414becd4834606010acd1c8ac1941e9/d4c13/cicd.png 825w,\n/static/a414becd4834606010acd1c8ac1941e9/f0551/cicd.png 862w\"\n        sizes=\"(max-width: 550px) 100vw, 550px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>자동화 도구로는 Github Actions를 사용했습니다. 각 Repository 특정 브랜치에 푸시하게 되면, 자동으로 도커 이미지를 빌드하고 EC2에 접속하여 새 이미지를 Pull받은 후 이미지들을 다시 실행시켜주게 됩니다.</p>\n<h3>깃허브 액션 파일 설정</h3>\n<p>깃허브 액션은 yml 파일을 통해 workflow를 구성할 수 있습니다.\n이 파일은 Repository의 Actions탭에서 New workflow를 클릭하여 생성하거나 Repository에 .github/workflows 디렉토리 안에 yml 파일을 생성하여 구성할 수 있습니다.</p>\n<h4>frontend</h4>\n<deckgo-highlight-code language=\"yml\"  >\n          <code slot=\"code\">#front-deploy.yml\n\nname: Deploy\n\non:\npush:\nbranches:\n\n- main\n\njobs:\nbuild:\n\n# 실행 환경 지정\n\nruns-on: ubuntu-latest\n\nstrategy:\nmatrix:\nnode-version: [20.5.x]\n\nsteps:\n\n- uses: actions/checkout@v2\n- name: Use Node.js ${{ matrix.node-version }}\n  uses: actions/setup-node@v1\n  with:\n  node-version: ${{ matrix.node-version }}\n\n  # 도커 로그인하고 도커 이미지 빌드 후 푸시한다.\n\n- name: web docker build and push\n  run: |\n  docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_PASSWORD }}\n  docker build --platform linux/amd64 -t ${{ secrets.DOCKER_USERNAME }}/randps-front .\n  docker push ${{ secrets.DOCKER_USERNAME }}/randps-front\n\n  # Github Actions IP 가져온다.\n\n- name: Get Github Actions IP\n  id: ip\n  uses: haythem/public-ip@v1.2\n\n- name: Configure AWS Credentials\n  uses: aws-actions/configure-aws-credentials@v1\n  with:\n  aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n  aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n  aws-region: ap-northeast-2\n\n  # Github Actions IP를 AWS 보안그룹에 추가한다.\n\n- name: Add Github Actions IP to Security group\n  run: |\n  aws ec2 authorize-security-group-ingress --group-id ${{ secrets.AWS_SG_ID }} --protocol tcp --port 22 --cidr ${{ steps.ip.outputs.ipv4 }}/32\n\n  # ssh로 EC2 접속해서 도커 컨테이너를 모두 멈춘 후, 도커 파일을 새로 받아 다시 docker-compose로 이미지를 실행시킨다.\n\n- name: executing remote ssh commands using password\n  uses: appleboy/ssh-action@master\n  with:\n  host: ${{ secrets.HOST_ID }}\n  username: ubuntu\n  key: ${{ secrets.PRIVATE_KEY }}\n  script: |\n  sudo docker rm -f $(sudo docker ps -qa)\n  sudo docker pull ${{ secrets.DOCKER_USERNAME }}/randps-front\n  sudo docker-compose up -d\n  sudo docker image prune -f\n\n  # AWS 보안그룹에서 Github Actions IP를 삭제한다.\n\n- name: Remove Github Actions IP From Security Group\n  run: |\n  aws ec2 revoke-security-group-ingress --group-id ${{ secrets.AWS_SG_ID }} --protocol tcp --port 22 --cidr ${{ steps.ip.outputs.ipv4 }}/32```\n</code>\n        </deckgo-highlight-code>\n<p>이 파일은 GitHub Actions를 사용하여 프론트엔드 웹 애플리케이션을 빌드하고 AWS EC2 인스턴스에 배포하는 작업을 정의합니다.</p>\n<p>먼저 main 브랜치로의 push 이벤트에 의해 트리거 되면 해당 워크플로우가 ubuntu-latest 운영체제 환경에서 실행됩니다.</p>\n<p>그리고 actions/setup-node@v1 액션을 사용하여 Node.js 환경을 설정합니다.</p>\n<p>그 다음에는 docker login을 사용하여 Docker Hub에 로그인하고\n애플리케이션의 Docker 이미지를 빌드하고 Docker Hub에 푸시합니다.</p>\n<p>haythem/public-<a href=\"mailto:ip@v1.2\">ip@v1.2</a> 액션을 사용하여 GitHub Actions의 공용 IP 주소를 가져옵니다. 이 IP 주소는 보안 그룹 설정에 사용됩니다.</p>\n<p>AWS 자격 증명을 설정하기 위해 aws-actions/configure-aws-credentials@v1 액션을 사용합니다. 이 작업은 AWS 서비스와 상호 작용하기 위해 필요합니다.</p>\n<p>그리고 AWS 보안 그룹에 GitHub Actions IP를 추가합니다.\naws ec2 authorize-security-group-ingress 명령을 사용하여 AWS 보안 그룹에 SSH 포트(22)로의 인바운드 액세스를 GitHub Actions의 IP 주소로 추가합니다.</p>\n<p>appleboy/ssh-action@master 액션을 사용하여 원격 EC2 서버에 SSH 연결하고 명령을 실행합니다.\n원격 서버에서 실행되는 명령들은 아래와 같습니다.</p>\n<p>먼저 현재 실행 중인 Docker 컨테이너를 모두 중지 및 제거합니다.\n이후 Docker Hub에서 새로운 프론트엔드 Docker 이미지를 가져오고, Docker Compose를 사용하여 컨테이너를 시작합니다.\n그리고 더 이상 사용되지 않는 Docker 이미지를 정리합니다.</p>\n<p>작업이 완료되면 aws ec2 revoke-security-group-ingress 명령을 사용하여 AWS 보안 그룹에서 GitHub Actions IP 주소로의 SSH 액세스를 제거합니다.</p>\n<h4>깃허브 시크릿 등록</h4>\n<h4>backend</h4>\n<deckgo-highlight-code language=\"yml\"  >\n          <code slot=\"code\"># This workflow will build a Java project with Gradle\n# For more information see: https://help.github.com/actions/language-and-framework-guides/building-and-testing-java-with-gradle\n\nname: Spring Boot &amp; Gradle CI/CD\n\non:\n push:\n  branches:\n   - master\n\njobs:\n build:\n  # 실행 환경 지정\n  runs-on: ubuntu-latest\n\n  steps:\n   - uses: actions/checkout@v2\n\n   - name: Set up JDK 11\n     uses: actions/setup-java@v1\n     with:\n      java-version: 11\n\n   - name: Grant execute permission for gradlew\n     run: chmod +x gradlew\n\n     # 스프링부트 코드 Build\n   - name: Build with Gradle\n     run: ./gradlew clean build\n\n     # 도커 로그인하고 도커 이미지 빌드 후 푸시한다.\n   - name: web docker build and push\n     run: |\n      docker login -u ${{ secrets.DOCKER_USERNAME }} -p ${{ secrets.DOCKER_PASSWORD }}\n      docker build --platform linux/amd64 -t ${{ secrets.DOCKER_USERNAME }}/randps-back .\n      docker push ${{ secrets.DOCKER_USERNAME }}/randps-back\n\n     # Github Actions IP 가져온다.\n   - name: Get Github Actions IP\n     id: ip\n     uses: haythem/public-ip@v1.2\n\n   - name: Configure AWS Credentials\n     uses: aws-actions/configure-aws-credentials@v1\n     with:\n      aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}\n      aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}\n      aws-region: ap-northeast-2\n\n     # Github Actions IP를 AWS 보안그룹에 추가한다.\n   - name: Add Github Actions IP to Security group\n     run: |\n      aws ec2 authorize-security-group-ingress --group-id ${{ secrets.AWS_SG_ID }} --protocol tcp --port 22 --cidr ${{ steps.ip.outputs.ipv4 }}/32\n\n     # ssh로 EC2 접속해서 도커 컨테이너를 모두 멈춘 후, 도커 파일을 새로 받아 다시 docker-compose로 이미지를 실행시킨다.\n   - name: executing remote ssh commands using password\n     uses: appleboy/ssh-action@master\n     with:\n      host: ${{ secrets.HOST_ID }}\n      username: ubuntu\n      key: ${{ secrets.PRIVATE_KEY }}\n      script: |\n       sudo docker rm -f $(sudo docker ps -qa)\n       sudo docker pull ${{ secrets.DOCKER_USERNAME }}/randps-back\n       sudo docker-compose up -d\n       sudo docker image prune -f\n\n     # AWS 보안그룹에서 Github Actions IP를 삭제한다.\n   - name: Remove Github Actions IP From Security Group\n     run: |\n      aws ec2 revoke-security-group-ingress --group-id ${{ secrets.AWS_SG_ID }} --protocol tcp --port 22 --cidr ${{ steps.ip.outputs.ipv4 }}/32```</code>\n        </deckgo-highlight-code>\n<p>도커 이미지 이름과 도커 이미지 빌드 전 gradle build 단계가 추가된 것 이외에는 frontend 쪽의 로직과 동일합니다.</p>\n<p>이렇게 해주고 지정한 브랜치에 푸시하면 자동으로 배포가 되고 있는 것을 확인할 수 있습니다! 예에</p>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EC%A0%84%EC%B2%B4%EC%A0%81%EC%9D%B8-%EA%B5%AC%EC%A1%B0\">전체적인 구조</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B0%B0%ED%8F%AC-%EA%B3%BC%EC%A0%95\">배포 과정</a></p>\n<ul>\n<li>\n<p><a href=\"#%EB%8F%84%EB%A9%94%EC%9D%B8-%EA%B5%AC%EC%9E%85-%EB%B0%8F-%EC%97%B0%EB%8F%99\">도메인 구입 및 연동</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%8F%84%EC%BB%A4-%ED%8C%8C%EC%9D%BC-%EC%9E%91%EC%84%B1\">도커 파일 작성</a></p>\n<ul>\n<li><a href=\"#frontend\">frontend</a></li>\n<li><a href=\"#nginxconf\">nginx.conf</a></li>\n<li><a href=\"#backend\">backend</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#ssl-%EC%9D%B8%EC%A6%9D%EC%84%9C-%EB%B0%9C%EA%B8%89\">SSL 인증서 발급</a></p>\n</li>\n<li>\n<p><a href=\"#docker-composeyml-%ED%8C%8C%EC%9D%BC-%EC%83%9D%EC%84%B1\">docker-compose.yml 파일 생성</a></p>\n<ul>\n<li><a href=\"#backend-1\">backend</a></li>\n<li><a href=\"#frontend-1\">frontend</a></li>\n<li><a href=\"#nginx\">nginx</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%B0%B0%ED%8F%AC\">배포</a></p>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%EB%B0%B0%ED%8F%AC-%EC%9E%90%EB%8F%99%ED%99%94\">배포 자동화</a></p>\n<ul>\n<li>\n<p><a href=\"#%EA%B9%83%ED%97%88%EB%B8%8C-%EC%95%A1%EC%85%98-%ED%8C%8C%EC%9D%BC-%EC%84%A4%EC%A0%95\">깃허브 액션 파일 설정</a></p>\n<ul>\n<li><a href=\"#frontend-2\">frontend</a></li>\n<li><a href=\"#%EA%B9%83%ED%97%88%EB%B8%8C-%EC%8B%9C%ED%81%AC%EB%A6%BF-%EB%93%B1%EB%A1%9D\">깃허브 시크릿 등록</a></li>\n<li><a href=\"#backend-2\">backend</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"Spring Boot/React 웹 서비스 배포하기","date":"September 13, 2023","description":"SSL을 적용하고 EC2와 Docker, Nginx를 사용하여 배포를 해봤습니다.","category":"프로젝트","icon":"🌏"}},"previous":{"fields":{"slug":"/csr-ssr/"},"frontmatter":{"title":"CSR과 SSR"}},"next":null},"pageContext":{"id":"4d9d8f78-9ab5-528a-8fbf-892acff26925","previousPostId":"c6e1d8a1-e51a-55bb-8813-024c41300f28","nextPostId":null}},"staticQueryHashes":["2841359383"],"slicesMap":{}}