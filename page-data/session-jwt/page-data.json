{"componentChunkName":"component---src-pages-blog-post-js","path":"/session-jwt/","result":{"data":{"site":{"siteMetadata":{"title":"klloo"}},"markdownRemark":{"id":"40e25bf3-e410-5c19-a88a-b02a09f999bc","excerpt":"개인 프로젝트를 진행하며 로그인 기능을 구현했던 과정을 기록해보려고 합니다. 백엔드 개발자와 협의하여 로그인은 JWT…","html":"<p>개인 프로젝트를 진행하며 로그인 기능을 구현했던 과정을 기록해보려고 합니다.</p>\n<p>백엔드 개발자와 협의하여 로그인은 JWT를 사용하여 구성하기로 했는데 토큰 방식의 로그인에 개념은 어렴풋이 알고 있었지만 막상 바로 적용하려 하니 어려움이 있어서 먼저 해당 개념에 대해 공부를 했습니다.</p>\n<h2>로그인 방식</h2>\n<p>로그인을 구성하는 방식은 크게 쿠키와 세션을 사용하는 방식과 토큰 기반의 인증 방식으로 나뉩니다.</p>\n<h3>세션 기반 인증</h3>\n<p>세션 기반 인증 방식을 이해하기 위해서는 먼저 쿠키와 세션에 대해 알아야 합니다.</p>\n<p><strong>쿠키</strong>란 서버에서 사용자의 웹브라우저에 저장하는 작은 데이터 조각입니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/20ef8755197c895185c2fd7c405fe9b0/29b94/cookie.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 81.15942028985506%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAQABQDASIAAhEBAxEB/8QAGAAAAgMAAAAAAAAAAAAAAAAAAAIBAwX/xAAUAQEAAAAAAAAAAAAAAAAAAAAA/9oADAMBAAIQAxAAAAHcVoLAD//EABkQAAEFAAAAAAAAAAAAAAAAABABESIxQf/aAAgBAQABBQLXC3If/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFxAAAwEAAAAAAAAAAAAAAAAAABAxAf/aAAgBAQAGPwIuqP8A/8QAGxAAAgIDAQAAAAAAAAAAAAAAAREhMQAQYXH/2gAIAQEAAT8hPcLEVXo0ykBV4ISjr//aAAwDAQACAAMAAAAQ88//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAdEAACAgIDAQAAAAAAAAAAAAABEQAhMUFRgaHw/9oACAEBAAE/EDIFro+qFNCA5yeQYgPJYE9cQHWnuu4GrzP/2Q=='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"cookie\"\n        title=\"\"\n        src=\"/static/20ef8755197c895185c2fd7c405fe9b0/d7854/cookie.jpg\"\n        srcset=\"/static/20ef8755197c895185c2fd7c405fe9b0/a81b0/cookie.jpg 138w,\n/static/20ef8755197c895185c2fd7c405fe9b0/35f54/cookie.jpg 275w,\n/static/20ef8755197c895185c2fd7c405fe9b0/d7854/cookie.jpg 550w,\n/static/20ef8755197c895185c2fd7c405fe9b0/0ea46/cookie.jpg 825w,\n/static/20ef8755197c895185c2fd7c405fe9b0/29b94/cookie.jpg 897w\"\n        sizes=\"(max-width: 550px) 100vw, 550px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>사용자가 웹사이트에 접근하여 HTTP 요청을 하면 서버는 쿠키를 생성하고 정보를 담아 HTTP 응답을 돌려줄 때, 같이 클라이언트에게 돌려줍니다.\n넘겨받은 쿠키는 클라이언트가 가지고 있다가 다시 서버에 요청할 때 요청과 함께 쿠키를 전송합니다.</p>\n<p><strong>세션</strong>이란 일정 시간 동안 같은 사용자로부터 들어오는 요구들을 하나의 상태로 보고, 그 상태를 유지시키는 기술입니다.\n여기서 일정 시간이란 클라이이언트가 웹서버에 연결된 순간부터 웹 브라우저를 닫아 서버와의 HTTP 통신을 끝낼 때 까지의 기간을 의미합니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/8942b4f93242e9f2ba653f1e3df769a8/bb3bf/session.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 68.84057971014492%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAAOABQDASIAAhEBAxEB/8QAFwAAAwEAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdxUixB//8QAGhAAAgIDAAAAAAAAAAAAAAAAAAEQERIxQf/aAAgBAQABBQLtw0Yi1//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8BP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8BP//EABcQAAMBAAAAAAAAAAAAAAAAAAAQMUH/2gAIAQEABj8CNVKv/8QAGRABAAMBAQAAAAAAAAAAAAAAAQARIYFx/9oACAEBAAE/IV0W8mXeKg2DVRFdE9IKBP/aAAwDAQACAAMAAAAQUM//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAEDAQE/ED//xAAUEQEAAAAAAAAAAAAAAAAAAAAQ/9oACAECAQE/ED//xAAcEAACAgMBAQAAAAAAAAAAAAABEQAhMUFhcdH/2gAIAQEAAT8QNaKFBYjFOgW+Jdhg0ciUoCEhrsCePJbBKCZzP//Z'); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"session\"\n        title=\"\"\n        src=\"/static/8942b4f93242e9f2ba653f1e3df769a8/d7854/session.jpg\"\n        srcset=\"/static/8942b4f93242e9f2ba653f1e3df769a8/a81b0/session.jpg 138w,\n/static/8942b4f93242e9f2ba653f1e3df769a8/35f54/session.jpg 275w,\n/static/8942b4f93242e9f2ba653f1e3df769a8/d7854/session.jpg 550w,\n/static/8942b4f93242e9f2ba653f1e3df769a8/0ea46/session.jpg 825w,\n/static/8942b4f93242e9f2ba653f1e3df769a8/ddced/session.jpg 1100w,\n/static/8942b4f93242e9f2ba653f1e3df769a8/bb3bf/session.jpg 1132w\"\n        sizes=\"(max-width: 550px) 100vw, 550px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>클라이언트가 서버에 요청을 보내면 서버에서는 요청헤더(쿠키)를 확인하고 세션 ID가 있는지 확인합니다.\n요청에 세션 ID가 없다면 서버에서는 세션 객체를 생성하여 정보를 저장한 뒤 응답을 보낼 때 쿠키에 세션 ID를 담아서 보냅니다.\n클라이언트는 응답에서 받은 세션 쿠키(세션 ID 값)를 저장해두고, 매번 해당 서버에 요청을 보낼 때마다 세션 쿠키를 함께 보내서 자신이 누구인지 인증하고 세션 쿠키는 브라우저가 종료되면 삭제됩니다.</p>\n<h4>그래서 세션 기반 인증 방식이란?</h4>\n<p>사용자의 인증 정보가 서버의 세션 저장소에 저장되는 방식입니다.</p>\n<p>사용자가 로그인을 하면, 해당 인증 정보를 서버의 세션 저장소에 저장하고, 사용자에게는 세션ID를 발급하여 브라우저에 쿠키 형태로 저장합니다.</p>\n<p>인증 절차를 마친 후 클라이언트는 요청마다 Cookie 헤더에 세션ID를 서버로 전송합니다. 그러면 서버가 세션ID에 해당하는 세션 정보가 세션 저장소에 존재하는지 확인하여 해당 클라이언트를 인증된 클라이언트로 판단하는 것입니다.</p>\n<h4>장단점은?</h4>\n<p>서버에서 클라이언트의 상태를 유지하고 있으므로, 사용자의 로그인 여부 확인이 용이하고, 클라이언트가 임의로 정보를 변경시키더라도 서버에서 클라이언트의 상태 정보를 가지고 있으므로 상대적으로 안전하다는 장점이 있습니다.</p>\n<p>하지만 서버에서 클라이언트의 상태를 모두 유지하고 있어야 하므로, 클라이언트 수에 따른 메모리나 DB에 부하가 심하다는 단점이 있습니다. 세션 용 DB를 사용하는 방법도 있지만 추후 서버를 확장하는 상황에서 서버간에 세션을 공유하는 방식도 복잡해집니다.\n또한 웹 브라우저에서 세션 관리에 사용하는 쿠키는 단일 도메인에서만 작동하도록 설계되어 CORS 방식을 사용할 때 쿠키 및 세션 관리가 어려워진다는 단점도 있습니다.</p>\n<h3>토큰 기반 인증</h3>\n<p>토큰 기반 인증은 인증 정보를 클라이언트가 직접 가지고 있는 방식입니다. 이때 인증 정보는 토큰의 형태로 브라우저의 로컬 스토리지 또는 쿠키에 저장됩니다.</p>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 550px; overflow: hidden!important; border-radius: 8px!important; margin-left: 0!important;\"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/a95575ea0a1a0bd12da6321edfcbcad5/67d3c/token.jpg\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 65.21739130434783%; position: relative; bottom: 0; left: 0; background-image: url('data:image/jpeg;base64,/9j/2wBDABALDA4MChAODQ4SERATGCgaGBYWGDEjJR0oOjM9PDkzODdASFxOQERXRTc4UG1RV19iZ2hnPk1xeXBkeFxlZ2P/2wBDARESEhgVGC8aGi9jQjhCY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2NjY2P/wgARCAANABQDASIAAhEBAxEB/8QAFwABAAMAAAAAAAAAAAAAAAAAAAECBf/EABQBAQAAAAAAAAAAAAAAAAAAAAD/2gAMAwEAAhADEAAAAdyQsD//xAAYEAEAAwEAAAAAAAAAAAAAAAABABAxEf/aAAgBAQABBQJ02JOV/8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAwEBPwE//8QAFBEBAAAAAAAAAAAAAAAAAAAAEP/aAAgBAgEBPwE//8QAFxAAAwEAAAAAAAAAAAAAAAAAABAxQf/aAAgBAQAGPwI1Uq//xAAbEAACAwADAAAAAAAAAAAAAAABMQARQRAhYf/aAAgBAQABPyEuwsrJ6JvFhZQU1Ap//9oADAMBAAIAAwAAABAzD//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQMBAT8QP//EABQRAQAAAAAAAAAAAAAAAAAAABD/2gAIAQIBAT8QP//EAB4QAQADAAAHAAAAAAAAAAAAAAEAESEQMUFRYbHB/9oACAEBAAE/EE7BNHY3D4A+8FZoGlHuZtcrnBQLWurP/9k='); background-size: cover; display: block;\"\n  ></span>\n  <img\n        class=\"gatsby-resp-image-image\"\n        alt=\"token\"\n        title=\"\"\n        src=\"/static/a95575ea0a1a0bd12da6321edfcbcad5/d7854/token.jpg\"\n        srcset=\"/static/a95575ea0a1a0bd12da6321edfcbcad5/a81b0/token.jpg 138w,\n/static/a95575ea0a1a0bd12da6321edfcbcad5/35f54/token.jpg 275w,\n/static/a95575ea0a1a0bd12da6321edfcbcad5/d7854/token.jpg 550w,\n/static/a95575ea0a1a0bd12da6321edfcbcad5/0ea46/token.jpg 825w,\n/static/a95575ea0a1a0bd12da6321edfcbcad5/ddced/token.jpg 1100w,\n/static/a95575ea0a1a0bd12da6321edfcbcad5/67d3c/token.jpg 1131w\"\n        sizes=\"(max-width: 550px) 100vw, 550px\"\n        style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n        loading=\"lazy\"\n        decoding=\"async\"\n      />\n  </a>\n    </span></p>\n<p>사용자가 아이디와 비밀번호를 입력하고 서버로 요청을 보내면 서버는 db에서 회원을 조회하고 등록된 사용자라면 토큰을 생성하여 클라이언트에 토큰과 함께 응답을 보냅니다.\n응답이 성공적으로 왔다면 클라이언트는 이후 인증이 필요한 모든 요청에 해당 토큰을 Authorization헤더에 실어 보냅니다.\n그러면 서버는 요청 헤더로 전달받은 토큰을 검증하고 권한이 있는 사용자라고 판단하면 요청된 데이터를 응답해 주는 것입니다.</p>\n<p>하지만 이 때 한가지 주의 사항이 있습니다. 토큰은 발급 시 유효기간 동안 되돌릴 수 없고 탈취당할 경우 토큰에는 인증 정보가 모두 담겨있으므로 위험합니다.\n이를 해결하기 위해 서버에서는 Access token과 Refresh token 두개의 토큰을 발행 합니다.</p>\n<p><strong>Access Token</strong>: 클라이언트 쪽에서 요청 헤더에 담아 보내는 토큰 입니다.</p>\n<p><strong>Refresh Token</strong>: Access Token이 만료되거나 잘못된 토큰일 경우 Refresh Token을 사용해 유저를 검증합니다. 만약 Refresh Token을 검증하여 인증된 유저일 경우 Access Token을 재발행 해줍니다.</p>\n<p>결론적으로 Access Token의 유효기간을 짧게 설정하고 Refresh Token의 유효기간을 길게 설정하여 Access Token 만료시 Refresh Token을 검증하여 Access Token을 재발행 해주는 것으로 보안적으로 안전하게 유저 인증을 관리 할 수 있습니다.</p>\n<h4>장단점은?</h4>\n<p>클라이언트가 토큰 정보를 갖고 있기 때문에 서버를 확장하는데 부담이 적고, 클라이언트 세션 관리에 대한 서버의 메모리 부담을 줄일 수 있다는 장점이 있습니다.</p>\n<p>하지만 인증 정보가 담긴 토큰이 탈취될 수도 있기 때문에 보안에 취약하며 토큰에 부가적인 정보가 담겨 있기에 서버-클라이언트 간 주고 받는 데이터가 세션 기반의 인증보다 많다는 단점이 있습니다.</p>\n<h4>그럼 JWT란?</h4>\n<p>JWT(Json Web Token)는 말그대로 웹에서 사용되는 JSON 형식의 토큰에 대한 표준 규격입니다.</p>\n<p>하나의 JWT 토큰은 헤더(header)와 페이로드(payload), 서명(signature) 이렇게 세 부분으로 이루어지며 각 구역이 . 기호로 구분됩니다.</p>\n<p><code class=\"language-text\">&lt;헤더>.&lt;페이로드>.&lt;서명></code></p>\n<p>헤더에는 토큰의 유형과 서명 알고리즘에 명시되고, 페이로드에는 소위 claim이라고도 불리는 사용자의 인증/인가 정보가, 서명에는 헤더와 페이로드가 비밀키로 서명되어 저장됩니다.</p>\n<p>JWT 토큰은 네트워크로 전송되야 하기 때문에 공간을 적게 차지하는 것이 유리합니다. 그래서 JSON 형식으로 데이터를 저장할 때 키를 3글자로 줄이는 독특한 관행이 있습니다.</p>\n<h2>토큰의 저장 위치</h2>\n<p>토큰을 기반으로 구성한 로그인 방식에서 많은 고민이 필요한 부분 중 하나는 토큰을 안전하게 저장하는 위치인 것 같습니다.</p>\n<p>처음에는 이 부분이 막막해서 구글링을 열심히 해봤는데 결국 제가 내린 결론은 \"정답은 없다\" 였습니다. 검색 결과로 나온 방법들마다 구현 방식이 조금씩 달랐고, 100% 안전한 방식은 없는 것 같았습니다.</p>\n<p>그래도 일반적으로 언급되고 있는 몇 가지 중요한 내용이 있어서 그 부분에 대해서 살펴봤습니다.</p>\n<p>토큰의 저장 위치를 고민해야하는 이유는 바로 보안 때문입니다. 웹 어플리케이션 보안 취약점 중 유저 인증에서 보편적으로 이용되는 취약점은 XSS와 CSRF 공격 두 가지가 있습니다.</p>\n<h3>XSS(Cross-Site Scripting) 공격</h3>\n<p>웹사이트에서 의도치 않은 스크립트를 넣어서 실행시키는 기법을 말합니다. 보통 게시판에 악성 스크립트가 담긴 글을 올리는 형태로 이루어지며, 스크립트가 포함된 글을 열어보게 되면 브라우저에서 원치 않는 스크립트가 실행되는 방식입니다.</p>\n<p>이것을 통해 사용자의 쿠키 정보를 탈취하거나, 사용자 비밀번호를 변경하는 API를 호출하는 행위를 할 수 있습니다.</p>\n<h3>CSRF(Cross-Site Request Forgery) 공격</h3>\n<p>공격자가 다른 사이트에서 API를 요청해 실행하는 공격입니다.\nAPI를 요청할 수 있는 클라이언트 도메인이 누구인지 서버에서 통제하고 있지 않다면 CSRF가 가능한데, 이때 공격자가 클라이언트에 저장된 사용자 인증정보를 서버에 보낼 수 있다면, 제대로 로그인한 것처럼 사용자의 정보를 변경하거나 사용자만 가능한 액션들을 수행할 수 있습니다.</p>\n<p>예를 들어 CSRF에 취약한 은행 사이트가 있다면 로그인한 척 계좌 비밀번호를 바꾸거나 송금을 보낼 수 있는 것입니다.</p>\n<h3>브라우저 저장소 종류 별 보안 이슈</h3>\n<p>클라이언트에서 위 프로세스들을 따라 Access Token 같은 인증정보를 저장할 때 이용하는 저장소는 보통 localStorage나 쿠키입니다.</p>\n<p>둘 다 브라우저에 저장하는 방식으로 페이지를 새로고침 하거나 창을 닫고 다시 접속할 때도 로그인 정보가 이어지도록하기 위해서입니다. 하지만 두 방식은 XSS와 CSRF 공격에 취약할 수 있습니다.</p>\n<h4>localStorage 저장 방식</h4>\n<p>브라우저 저장소에 저장하는 방식으로 자바스크립트 내 글로벌 변수로 읽기 및 쓰기 접근이 가능합니다.</p>\n<p>😈 자바스크립트로 접근이 가능하기 때문에 Refresh Token 또는 Access Token을 저장해두면 XSS 취약점을 통해 그 안에 담긴 값을 이용해 API 요청을 위조할 수 있습니다.</p>\n<h4>쿠키 저장 방식</h4>\n<p>브라우저에 쿠키로 저장되고 클라이언트가 HTTP 요청을 보낼 때마다 자동으로 쿠키가 서버에 전송됩니다. 자바스크립트 내 글로벌 변수로 읽기 및 쓰기 접근이 가능합니다.</p>\n<p>😈 localStorage 저장 방식과 마찬가지로 Refresh Token, Access Token을 쿠키에 저장해두면 XSS 취약점이 있을 때 담긴 값들을 불러오거나, API 콜을 보내면 쿠키에 담긴 값들이 함께 전송되어 로그인한 척 공격을 수행할 수 있게 됩니다.</p>\n<p>😈 쿠키에 Access Token을 저장해 인증에 이용하는 구조에 CSRF 취약점이 있다면 인증 정보가 쿠키에 담겨 서버로 보내지며 공격자는 유저 권한으로 정보를 가져올 수 있습니다.</p>\n<p>😇 쿠키에 Refresh Token만 저장하고 새로운 Access Token을 받아와 인증에 이용하는 구조에서는 CSRF 취약점 공격을 방어할 수 있습니다.\nCSRF는 정상 사용자가 img 태그를 보거나 link를 클릭하도록 유도하여 사용자 대신 request를 보내는 방법입니다. Refresh Token은 쿠키로 저장되어 있기 때문에 CSRF를 통해 Access Token을 사용자 대신 요청할 순 있지만 response는 사용자가 받기 때문에 공격자는 이 Access Token을 얻지 못하기 때문입니다.</p>\n<h4>secure httpOnly 쿠키 저장 방식</h4>\n<p>브라우저에 쿠키로 저장되는 건 같지만, 자바스크립트 내에서 접근이 불가능합니다. secure을 적용하면 https 접속에서만 동작하게 됩니다.</p>\n<p>😇 httpOnly 쿠키 방식으로 저장된 정보는 자바스크립트 내에서 접근이 불가능하므로 XSS 취약점 공격으로 담긴 값을 불러올 수 없습니다.</p>\n<p>😇 httpOnly 쿠키 역시 Refresh Token만 저장하고 Access Token을 받아와 인증에 이용하는 구조로 CSRF 공격 방어가 가능합니다.</p>\n<p>😈 쿠키 저장 방식과 같은 이유로 Access Token은 저장하면 안됩니다.</p>\n<p>😈 httpOnly 쿠키에 담긴 값에 접근할 수는 없지만 XSS 취약점을 노려 API 콜을 요청하면 httpOnly 쿠키에 담긴 값들도 함께 보내져 유저인 척 정보를 빼오거나 액션을 수행할 수 있습니다.</p>\n<h4>결론</h4>\n<p>어떤 저장 방식을 택해도 XSS 취약점이 있다면 보안 이슈가 존재하게 됩니다. 그러므로 유저 정보 저장 방식을 바꾸는 것만으로는 방어할 수 없고, 클라이언트와 서버에서 추가적으로 XSS 방어 처리를 하는 것이 필수입니다.</p>\n<p>그래도 최선의 방법을 찾아보자면 Refresh Token만을 secure httpOnly 쿠키에 저장해 CSRF 공격을 방어하고 Access Token은 웹 어플리케이션 내 로컬 변수에 저장하여 API를 요청할 때 Authorization 헤더에 넣어 보내주는 것이 좋겠습니다. 하지만 XSS 취약점을 이용한 API 요청 공격은 무방비하니 XSS 자체를 막기 위해 클라이언트와 서버에서 추가적으로 방어할 필요가 있습니다.</p>\n<br/>\n<br/>\n<br/>\n<hr>\n<p><strong>Reference</strong></p>\n<p><a href=\"https://hoime.tistory.com/93\">https://hoime.tistory.com/93</a> <br/>\n<a href=\"https://hudi.blog/session-based-auth-vs-token-based-auth/\">https://hudi.blog/session-based-auth-vs-token-based-auth/</a><br/>\n<a href=\"https://millo-l.github.io/JWT-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D%EB%B0%A9%EC%8B%9D/\">https://millo-l.github.io/JWT-기반-인증방식/</a><br/>\n<a href=\"https://velog.io/@yaytomato/%ED%94%84%EB%A1%A0%ED%8A%B8%EC%97%90%EC%84%9C-%EC%95%88%EC%A0%84%ED%95%98%EA%B2%8C-%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EC%B2%98%EB%A6%AC%ED%95%98%EA%B8%B0#-%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%A0%80%EC%9E%A5%EC%86%8C-%EC%A2%85%EB%A5%98%EC%99%80-%EB%B3%B4%EC%95%88-%EC%9D%B4%EC%8A%88\">https://velog.io/@yaytomato/프론트에서-안전하게-로그인-처리하기#-브라우저-저장소-종류와-보안-이슈</a><br/>\n<a href=\"https://ssocoit.tistory.com/235\">https://ssocoit.tistory.com/235</a></p>","tableOfContents":"<ul>\n<li>\n<p><a href=\"#%EB%A1%9C%EA%B7%B8%EC%9D%B8-%EB%B0%A9%EC%8B%9D\">로그인 방식</a></p>\n<ul>\n<li>\n<p><a href=\"#%EC%84%B8%EC%85%98-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D\">세션 기반 인증</a></p>\n<ul>\n<li><a href=\"#%EA%B7%B8%EB%9E%98%EC%84%9C-%EC%84%B8%EC%85%98-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D-%EB%B0%A9%EC%8B%9D%EC%9D%B4%EB%9E%80\">그래서 세션 기반 인증 방식이란?</a></li>\n<li><a href=\"#%EC%9E%A5%EB%8B%A8%EC%A0%90%EC%9D%80\">장단점은?</a></li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%86%A0%ED%81%B0-%EA%B8%B0%EB%B0%98-%EC%9D%B8%EC%A6%9D\">토큰 기반 인증</a></p>\n<ul>\n<li><a href=\"#%EC%9E%A5%EB%8B%A8%EC%A0%90%EC%9D%80-1\">장단점은?</a></li>\n<li><a href=\"#%EA%B7%B8%EB%9F%BC-jwt%EB%9E%80\">그럼 JWT란?</a></li>\n</ul>\n</li>\n</ul>\n</li>\n<li>\n<p><a href=\"#%ED%86%A0%ED%81%B0%EC%9D%98-%EC%A0%80%EC%9E%A5-%EC%9C%84%EC%B9%98\">토큰의 저장 위치</a></p>\n<ul>\n<li>\n<p><a href=\"#xsscross-site-scripting-%EA%B3%B5%EA%B2%A9\">XSS(Cross-Site Scripting) 공격</a></p>\n</li>\n<li>\n<p><a href=\"#csrfcross-site-request-forgery-%EA%B3%B5%EA%B2%A9\">CSRF(Cross-Site Request Forgery) 공격</a></p>\n</li>\n<li>\n<p><a href=\"#%EB%B8%8C%EB%9D%BC%EC%9A%B0%EC%A0%80-%EC%A0%80%EC%9E%A5%EC%86%8C-%EC%A2%85%EB%A5%98-%EB%B3%84-%EB%B3%B4%EC%95%88-%EC%9D%B4%EC%8A%88\">브라우저 저장소 종류 별 보안 이슈</a></p>\n<ul>\n<li><a href=\"#localstorage-%EC%A0%80%EC%9E%A5-%EB%B0%A9%EC%8B%9D\">localStorage 저장 방식</a></li>\n<li><a href=\"#%EC%BF%A0%ED%82%A4-%EC%A0%80%EC%9E%A5-%EB%B0%A9%EC%8B%9D\">쿠키 저장 방식</a></li>\n<li><a href=\"#secure-httponly-%EC%BF%A0%ED%82%A4-%EC%A0%80%EC%9E%A5-%EB%B0%A9%EC%8B%9D\">secure httpOnly 쿠키 저장 방식</a></li>\n<li><a href=\"#%EA%B2%B0%EB%A1%A0\">결론</a></li>\n</ul>\n</li>\n</ul>\n</li>\n</ul>","frontmatter":{"title":"세션 기반 인증과 토큰 기반 인증","date":"September 04, 2023","description":"로그인 기능을 구현하기 전, 로그인 방식에 대해 알아보았습니다.","category":"FE","icon":"🎫"}},"previous":{"fields":{"slug":"/alteration-detective/"},"frontmatter":{"title":"첫 사이드 프로젝트 진행기"}},"next":{"fields":{"slug":"/make-streak/"},"frontmatter":{"title":"리액트로 자체 잔디 심기 기능 구현하기"}}},"pageContext":{"id":"40e25bf3-e410-5c19-a88a-b02a09f999bc","previousPostId":"e36dd6cc-6e8f-554c-bf85-fe68d2be47a6","nextPostId":"1fd909b8-e3a9-56c5-92b9-88b9eaf5524d"}},"staticQueryHashes":["2841359383"],"slicesMap":{}}